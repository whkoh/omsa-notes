<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-03-07 Thu 20:53 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CSE 8803: Applied Natural Language Processing</title>
<meta name="author" content="W" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="../src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="../src/readtheorg_theme/css/readtheorg.css"/>
<script type="text/javascript" src="../src/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="../src/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="../src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">CSE 8803: Applied Natural Language Processing</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org3285143">1. Week 1: Text data preprocessing + Course Intro</a>
<ul>
<li><a href="#orgfe56c3f">1.1. Why ANLP?</a></li>
<li><a href="#orgdbcbbaf">1.2. Lots of text and written information</a></li>
<li><a href="#org4033f6f">1.3. Example applications of NLP</a></li>
<li><a href="#orgf6922b6">1.4. Challenges of NLP</a></li>
<li><a href="#org0991781">1.5. Class overview</a></li>
<li><a href="#org685f029">1.6. Deliverables</a>
<ul>
<li><a href="#orge4df3f6">1.6.1. Homework</a></li>
<li><a href="#org27d623a">1.6.2. Quizzes (10)</a></li>
</ul>
</li>
<li><a href="#org1986970">1.7. Course goals</a></li>
<li><a href="#orgbfa2d63">1.8. Text Preprocessing Techniques</a>
<ul>
<li><a href="#orgc32f8bd">1.8.1. Terminology</a></li>
<li><a href="#org34875e2">1.8.2. Preprocessing text data</a></li>
<li><a href="#org7fc00c0">1.8.3. Noise removal</a></li>
<li><a href="#org8ded119">1.8.4. Tokenization</a></li>
<li><a href="#org8d46cb6">1.8.5. Text normalization</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgefb2bc9">2. Week 2: (Discrete) Text Representations</a>
<ul>
<li><a href="#org5bb7f60">2.1. Why?</a></li>
<li><a href="#org3a6ead7">2.2. Representing Words</a></li>
<li><a href="#org59b4f88">2.3. Representing sentences/documents</a></li>
<li><a href="#orgb965e72">2.4. One Hot Encoding</a>
<ul>
<li><a href="#org77e8976">2.4.1. Definitions</a></li>
<li><a href="#orgf3e4dbc">2.4.2. Advantages and disadvantages</a></li>
</ul>
</li>
<li><a href="#orgcdb7bea">2.5. Bag of Words (Frequency Counting)</a>
<ul>
<li><a href="#orgc799c0d">2.5.1. Advantages and disadvantages</a></li>
</ul>
</li>
<li><a href="#orgcda748f">2.6. TF-IDF (Term Frequency-Inverse Document Frequency)</a>
<ul>
<li><a href="#org6dd5044">2.6.1. Why needed?</a></li>
<li><a href="#org1abb98a">2.6.2. What is TF-IDF and when to use TF-IDF</a></li>
<li><a href="#orgd84327a">2.6.3. Advantages and disadvantages</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2bba7e2">3. Week 3: Linear Text Classification</a>
<ul>
<li><a href="#org8297dd8">3.1. Classification introduction</a>
<ul>
<li><a href="#orge6fb61c">3.1.1. Supervised learning: definitions</a></li>
<li><a href="#org51cbea7">3.1.2. Categories of supervised learning</a></li>
<li><a href="#org104a806">3.1.3. Regression</a></li>
<li><a href="#org95da91b">3.1.4. Classification</a></li>
</ul>
</li>
<li><a href="#org0cdba92">3.2. Naive Bayes</a>
<ul>
<li><a href="#orgfb8cadd">3.2.1. Method / concepts</a></li>
<li><a href="#org7f83586">3.2.2. Bayes decision rule</a></li>
<li><a href="#org846dcd4">3.2.3. Generative vs discriminative models</a></li>
<li><a href="#org130cad8">3.2.4. Details of Naive Bayes</a></li>
<li><a href="#org039943e">3.2.5. Naive Conditional Independence Assumption</a></li>
<li><a href="#orgfb4f08b">3.2.6. Advantages and disadvantages</a></li>
</ul>
</li>
<li><a href="#org6c79fa8">3.3. Classification Model Evaluation</a>
<ul>
<li><a href="#org1e69e11">3.3.1. Common metrics</a></li>
<li><a href="#orgc1f3cde">3.3.2. Confusion matrix</a></li>
<li><a href="#org32d3a38">3.3.3. Accuracy</a></li>
<li><a href="#orgb9df380">3.3.4. RoC-AUC curve</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9e706dc">4. Week 5: Log Regression, SVM and Perceptron (Module 4)</a>
<ul>
<li><a href="#orgfd08760">4.1. Logistic Regression</a>
<ul>
<li><a href="#org6191f36">4.1.1. Generative vs Discriminative Models (again)</a></li>
<li><a href="#orga8008ca">4.1.2. Bayes equation again</a></li>
<li><a href="#org860620c">4.1.3. Logistic Function for posterior probability</a></li>
<li><a href="#org96bd956">4.1.4. Sigmoid is interpreted as probability</a></li>
<li><a href="#org40913b0">4.1.5. Logistic regression model</a></li>
<li><a href="#org2fa29aa">4.1.6. The gradient of \(l(\theta)\)</a></li>
<li><a href="#org513759f">4.1.7. Gradient descent</a></li>
<li><a href="#orgb6aa5c1">4.1.8. Gradient ascent (concave) / descent (convex) algorithm</a></li>
<li><a href="#org57289bd">4.1.9. Advantages and disadvantages of logistic regression</a></li>
</ul>
</li>
<li><a href="#orgccb7a9b">4.2. Support vector machine</a>
<ul>
<li><a href="#org5beac23">4.2.1. Linear separation</a></li>
<li><a href="#orgde23dbc">4.2.2. Finding &theta; that maximizes margin</a></li>
<li><a href="#org00ec0a2">4.2.3. Length of margin</a></li>
<li><a href="#orgfc85400">4.2.4. Maximizing margin</a></li>
<li><a href="#org16dc312">4.2.5. Geometric representation</a></li>
<li><a href="#org15cc892">4.2.6. Lagrange formulation (not in detail)</a></li>
<li><a href="#orgb73180a">4.2.7. Usage</a></li>
<li><a href="#orga2c5eca">4.2.8. From \(x\) to \(z\) space</a></li>
<li><a href="#org280489d">4.2.9. Support vector machine</a></li>
</ul>
</li>
<li><a href="#org4e8b7b8">4.3. Perceptron</a>
<ul>
<li><a href="#orgd23534f">4.3.1. Linearly separable</a></li>
<li><a href="#orgd6b74cf">4.3.2. Linear classifier</a></li>
<li><a href="#org8baa2ea">4.3.3. The Perceptron Classifier</a></li>
<li><a href="#org7ec7ee9">4.3.4. Perceptron activation</a></li>
<li><a href="#orgec86ac8">4.3.5. Advantages and disadvantages of Perceptron</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org93dce3c">5. Week 6: Embeddings/Dimensionality reduction</a>
<ul>
<li><a href="#orge7b8d48">5.1. SVD and Co-occurrence Embeddings</a>
<ul>
<li><a href="#orgca3bb66">5.1.1. Motivating example</a></li>
<li><a href="#org7314391">5.1.2. Bag of words representation</a></li>
<li><a href="#orgd4c5eb7">5.1.3. What is dimensionality reduction?</a></li>
<li><a href="#org08726ad">5.1.4. Intuition (of PCA)</a></li>
<li><a href="#org9a4eb54">5.1.5. Singular value decomposition</a></li>
<li><a href="#org6ae4eb3">5.1.6. Co-occurrence matrices</a></li>
<li><a href="#orgc33bfbe">5.1.7. SVD on co-occurrence matrices</a></li>
<li><a href="#org66bcd71">5.1.8. Dense word embeddings</a></li>
<li><a href="#orgb5ea655">5.1.9. Advantages of dense word embeddings</a></li>
</ul>
</li>
<li><a href="#org6b17a69">5.2. GloVe</a>
<ul>
<li><a href="#org24fbb56">5.2.1. Definitions</a></li>
<li><a href="#orgb8d86da">5.2.2. GloVe model</a></li>
<li><a href="#org780c8cd">5.2.3. Extending the co-occurrence matrix</a></li>
<li><a href="#orgaa31778">5.2.4. Example</a></li>
<li><a href="#org367d1d6">5.2.5. GloVe cost function</a></li>
<li><a href="#orgb733128">5.2.6. GloVe word vectors</a></li>
<li><a href="#org331ff68">5.2.7. GloVe conserves linear relationships</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb9ba954">6. Week 8: Neural Networks and Word2Vec</a>
<ul>
<li><a href="#org69f1152">6.1. Neural Networks</a>
<ul>
<li><a href="#org01e52e1">6.1.1. Inspiration from biological neurons</a></li>
<li><a href="#org70b34d3">6.1.2. Logistic regression block review</a></li>
<li><a href="#orgeb92abb">6.1.3. Connecting blocks to create neural networks</a></li>
<li><a href="#org3b8549b">6.1.4. Increasing the depth of each layer</a></li>
<li><a href="#org5fbcc3c">6.1.5. Increasing layers</a></li>
<li><a href="#orgb09e0c9">6.1.6. Forward pass</a></li>
<li><a href="#org0e5c7f9">6.1.7. Backpropagation</a></li>
</ul>
</li>
<li><a href="#orge3d37f9">6.2. Word2Vec, CBOW and Skipgram</a>
<ul>
<li><a href="#org06d9c5f">6.2.1. Review of One-Hot Encoding</a></li>
<li><a href="#org390d75d">6.2.2. Issues with One-Hot Embedding</a></li>
<li><a href="#org77c16f5">6.2.3. Contextual meaning of the words</a></li>
<li><a href="#orgdd4055e">6.2.4. What do we want to achieve from word embeddings?</a></li>
<li><a href="#org1b779ff">6.2.5. Algorithm 1:: Continuous Bag of Words (CBOW)</a></li>
<li><a href="#org32b71a6">6.2.6. Algorithm 2: Skip-Gram model</a></li>
<li><a href="#org415a0fe">6.2.7. Main differences between CBOW and Skip-gram</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org3285143" class="outline-2">
<h2 id="org3285143"><span class="section-number-2">1.</span> Week 1: Text data preprocessing + Course Intro</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgfe56c3f" class="outline-3">
<h3 id="orgfe56c3f"><span class="section-number-3">1.1.</span> Why ANLP?</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Text and docs are everywhere</li>
<li>Hundreds of languages in the world</li>
<li>Primary information artifacts</li>
<li>Large volumes of textual data</li>
<li>Big and small companies looking for this skill</li>
</ul>
</div>
</div>
<div id="outline-container-orgdbcbbaf" class="outline-3">
<h3 id="orgdbcbbaf"><span class="section-number-3">1.2.</span> Lots of text and written information</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>Internet</li>
<li>Webpages, Facebook, Wikipedia, etc.</li>
<li>Digital libraries: Google Books, ACM, IEEE</li>
<li>Lyrics, subtitles, etc.</li>
<li>Police case reports</li>
<li>Legislation</li>
<li>Reviews</li>
<li>Medical reports</li>
<li>Job descriptions</li>
</ul>
</div>
</div>
<div id="outline-container-org4033f6f" class="outline-3">
<h3 id="org4033f6f"><span class="section-number-3">1.3.</span> Example applications of NLP</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>Establish authenticity, detect plagiarism</li>
<li>Classification of genres</li>
<li>Classification of tone; sentiment analysis</li>
<li>Syntax analysis in code</li>
<li>Machine translation</li>
</ul>
</div>
</div>
<div id="outline-container-orgf6922b6" class="outline-3">
<h3 id="orgf6922b6"><span class="section-number-3">1.4.</span> Challenges of NLP</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>Interdisciplinary field</li>
<li>Ambiguity at many levels of language:
<ol class="org-ol">
<li>Lexical (Word level)</li>
<li>Syntactic: different ways of parsing</li>
<li>Partial information: e.g., how to interpret pronouns</li>
<li>Contextual information: context of sentence may affect meaning of sentence</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org0991781" class="outline-3">
<h3 id="org0991781"><span class="section-number-3">1.5.</span> Class overview</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>Preprocessing:
<ul class="org-ul">
<li>Clean text and documents</li>
<li>Tokenization</li>
<li>Reducing inflectional forms of a word:
<ul class="org-ul">
<li>Stemming</li>
<li>Lemmatization</li>
</ul></li>
<li>Normalization</li>
</ul></li>
<li>Text representation
<ul class="org-ul">
<li>One hot encoding</li>
<li>Bag of words (Frequency counting)</li>
<li>Term frequency-Inverse document frequency (TF-IDF)</li>
<li>Embeddings</li>
</ul></li>
<li>Overview of classification methods
<ul class="org-ul">
<li>Naive Bayes</li>
<li>Logistic regression</li>
<li>SVM</li>
<li>Perceptron</li>
<li>Nerual Network</li>
</ul></li>
<li>Overview of Deep Learning
<ul class="org-ul">
<li>Convolutional neural network</li>
<li>Recurrent neural network</li>
<li>Long short-term memory</li>
</ul></li>
<li>Overview of topic modelling
<ul class="org-ul">
<li>Principal component analysis</li>
<li>Singular value decomposition</li>
<li>Latent Dirichlet Allocation</li>
</ul></li>
<li>Overview of Transformer methods
<ul class="org-ul">
<li>Bidirectional Encoder Representations from Transformers</li>
<li>Generative Pre-trained Transformers (GPT)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org685f029" class="outline-3">
<h3 id="org685f029"><span class="section-number-3">1.6.</span> Deliverables</h3>
<div class="outline-text-3" id="text-1-6">
</div>
<div id="outline-container-orge4df3f6" class="outline-4">
<h4 id="orge4df3f6"><span class="section-number-4">1.6.1.</span> Homework</h4>
<div class="outline-text-4" id="text-1-6-1">
<ul class="org-ul">
<li>HW1: Text preprocessing and classification intro</li>
<li>HW2: Classification methods, dimensionality reduction, SVD</li>
<li>HW3: Deep learning</li>
<li>HW4: Transformers and unsupervised methods</li>
</ul>
</div>
</div>
<div id="outline-container-org27d623a" class="outline-4">
<h4 id="org27d623a"><span class="section-number-4">1.6.2.</span> Quizzes (10)</h4>
<div class="outline-text-4" id="text-1-6-2">
<ul class="org-ul">
<li>Measure understanding of topic</li>
<li>Mostly conceptual questions</li>
<li>MCQ</li>
<li>Limited time to do the test</li>
<li>Mandatory</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org1986970" class="outline-3">
<h3 id="org1986970"><span class="section-number-3">1.7.</span> Course goals</h3>
<div class="outline-text-3" id="text-1-7">
<ul class="org-ul">
<li>Demonstrate how to pre-process textual data</li>
<li>Differentiate text representation methods and techniques</li>
<li>Explain different NLP tasks</li>
<li>Develop and assess performance of different NLP models using a variety of techniques</li>
</ul>
</div>
</div>
<div id="outline-container-orgbfa2d63" class="outline-3">
<h3 id="orgbfa2d63"><span class="section-number-3">1.8.</span> Text Preprocessing Techniques</h3>
<div class="outline-text-3" id="text-1-8">
</div>
<div id="outline-container-orgc32f8bd" class="outline-4">
<h4 id="orgc32f8bd"><span class="section-number-4">1.8.1.</span> Terminology</h4>
<div class="outline-text-4" id="text-1-8-1">
<dl class="org-dl">
<dt>Corpus</dt><dd>collection of text, e.g. Yelp reviews, Wikipedia articles</dd>
<dt>Syntax</dt><dd>Grammatical structure of text</dd>
<dt>Syntactic parsing</dt><dd>process of analyzing natural language with grammatical rules</dd>
<dt>Semantics</dt><dd>meaning of text</dd>
<dt>Tokenization</dt><dd>splitting long pieces of text into smaller pieces (tokens). e.g.: <code>This is a simple sentence</code> -&gt; <code>["This", "is", "a", "simple", "sentence"]</code></dd>
<dt>Stop words</dt><dd>commonly used words, e.g. "the", "a", "an", "is", "are". Do not contribute to overall meaning</dd>
<dt>N-grams</dt><dd>consecutive sequence of words (commonly: 2-5) in a text. 1-gram (unigram), 2-gram (bigram), 3-gram (trigram). Example of bigrams: <code>"This is", "is a", "a simple", "simple sentence"</code></dd>
</dl>
</div>
</div>
<div id="outline-container-org34875e2" class="outline-4">
<h4 id="org34875e2"><span class="section-number-4">1.8.2.</span> Preprocessing text data</h4>
<div class="outline-text-4" id="text-1-8-2">
<ul class="org-ul">
<li>Text is unstructured, so preprocessing is the first step to prepare and clean text data to perform a NLP task</li>
<li>Useful libraries:
<ul class="org-ul">
<li>re: regular expressions</li>
<li>nltk: natural language toolkit</li>
</ul></li>
<li>Common steps:
<ul class="org-ul">
<li>Noise removal</li>
<li>Tokenization</li>
<li>Text normalization</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7fc00c0" class="outline-4">
<h4 id="org7fc00c0"><span class="section-number-4">1.8.3.</span> Noise removal</h4>
<div class="outline-text-4" id="text-1-8-3">
<p>
Removal of unwanted text formatting information, e.g.:
</p>
<ul class="org-ul">
<li>Punctuation</li>
<li>Accent marks</li>
<li>Special characters</li>
<li>Numeric digits (could be replaced with words)</li>
<li>Leading, ending and vertical whitespace</li>
<li>HTML formatting</li>
</ul>

<p>
Example: <code>This is a 'simple'' sentence !!! 1+ \n</code> -&gt; <code>This is a simple sentence</code>
</p>
</div>
</div>
<div id="outline-container-org8ded119" class="outline-4">
<h4 id="org8ded119"><span class="section-number-4">1.8.4.</span> Tokenization</h4>
<div class="outline-text-4" id="text-1-8-4">
<p>
Example:
<code>This is a simple sentence</code> -&gt;
<code>['This', 'is', 'a', 'simple', 'sentence', '.']</code>
</p>
</div>
</div>
<div id="outline-container-org8d46cb6" class="outline-4">
<h4 id="org8d46cb6"><span class="section-number-4">1.8.5.</span> Text normalization</h4>
<div class="outline-text-4" id="text-1-8-5">
<p>
Removing variations in the text to bring it to a standard form.
</p>
<ul class="org-ul">
<li>Case: Convert all letters to upper or lower case</li>
<li>Removing stop words, sparse terms, other special / particular words.</li>
</ul>

<p>
Example of text normalization:
<code>This is a Simple SenTence</code> -&gt;
<code>simple sentence</code>
</p>
<ul class="org-ul">
<li>Stemming: reduce words to word stem, base, or root form.
Example: <code>There are several tytpes of stemming algorithms</code> -&gt; <code>there are sever type fo stem algorithms.</code></li>
<li>Lemmatization: similar to stemming. Reduces inflectional forms to a common base form, <b><b>the lemma</b></b>. Does <b><b>not</b></b> simply chop off inflections. Uses <b><b>lexical knowledge</b></b> to get the correct base form of words.
Example: <code>There are several tytpes of stemming algorithms</code> -&gt; <code>There are several type of stemming algorithms.</code></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orgefb2bc9" class="outline-2">
<h2 id="orgefb2bc9"><span class="section-number-2">2.</span> Week 2: (Discrete) Text Representations</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org5bb7f60" class="outline-3">
<h3 id="org5bb7f60"><span class="section-number-3">2.1.</span> Why?</h3>
<div class="outline-text-3" id="text-2-1">
<dl class="org-dl">
<dt>NLP</dt><dd>design algorithms to allow computers to understand natural language, so as to perform some task</dd>
<dt>Required</dt><dd>convert text data to numerical data that can be used in model</dd>
</dl>
</div>
</div>
<div id="outline-container-org3a6ead7" class="outline-3">
<h3 id="org3a6ead7"><span class="section-number-3">2.2.</span> Representing Words</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>Can be represented by vectors of 0 &amp; 1 where 1 indicates the position of the word, e.g. lorem = <code>[1, 0]</code>, ipsum = <code>[0, 1]</code>, etc.</li>
</ul>
</div>
</div>
<div id="outline-container-org59b4f88" class="outline-3">
<h3 id="org59b4f88"><span class="section-number-3">2.3.</span> Representing sentences/documents</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>Vectors of vectors eg <code>[[1,0], [0,1]]</code></li>
</ul>
</div>
</div>
<div id="outline-container-orgb965e72" class="outline-3">
<h3 id="orgb965e72"><span class="section-number-3">2.4.</span> One Hot Encoding</h3>
<div class="outline-text-3" id="text-2-4">
</div>
<div id="outline-container-org77e8976" class="outline-4">
<h4 id="org77e8976"><span class="section-number-4">2.4.1.</span> Definitions</h4>
<div class="outline-text-4" id="text-2-4-1">
<dl class="org-dl">
<dt>corpus</dt><dd>all texts</dd>
<dt>vocabulary, <span class="underline">V</span></dt><dd>all unique words</dd>
<dt>vocabulary size, <span class="underline">d</span></dt><dd>number of unique words, "dimensions"</dd>
<dt>word, <span class="underline">w</span></dt><dd>represented by vector \(X\)</dd>
</dl>
<p>
\(X^w_i\) = 1 if idw(w) = 1, 0 otherwise
</p>
<dl class="org-dl">
<dt>document</dt><dd>represented by matrix sized \(n \times d\)</dd>
<dt><span class="underline">n</span></dt><dd>number of words in document</dd>
<dt><span class="underline">d</span></dt><dd>a single vector with multiple values of 1 where vocab. words are present</dd>
<dt>Document, <span class="underline">D</span></dt><dd>e.g. <span class="underline">this is a sentence</span></dd>
<dt>Vocabulary, <span class="underline">V</span></dt><dd>e.g. <code>[aardvark, ..., sentence, ..., zither]</code></dd>
<dt>OHE, \(X^D\)</dt><dd><code>[0, ..., 1, ...1]</code></dd>
</dl>
</div>
</div>
<div id="outline-container-orgf3e4dbc" class="outline-4">
<h4 id="orgf3e4dbc"><span class="section-number-4">2.4.2.</span> Advantages and disadvantages</h4>
<div class="outline-text-4" id="text-2-4-2">
<ul class="org-ul">
<li>Advantages: easy to implement</li>
<li>Disadvantages:
<ul class="org-ul">
<li>not scalable for large vocabulary</li>
<li>high dimensional sparse matrix results in expensive memory + computation</li>
<li><p>
each word represented individually, hence <b>no notion of similarity or meaning</b>. All vectors are orthogonal
</p>

<p>
\((w^{good})^T \cdot w^{great} = (w^{good})^T \cdot w^{bad} = 0\)
</p></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgcdb7bea" class="outline-3">
<h3 id="orgcdb7bea"><span class="section-number-3">2.5.</span> Bag of Words (Frequency Counting)</h3>
<div class="outline-text-3" id="text-2-5">
<dl class="org-dl">
<dt>Summary</dt><dd>Represents each document as a bag of words. <b><b>Ignores</b></b> order of words.</dd>
<dt>Document</dt><dd>a column vector of \(X\) word counts</dd>
<dt>Representation</dt><dd>Fixed-length representation</dd>
<dt>Document, <span class="underline">D</span></dt><dd>e.g. <code>It was the best of times, it was the worst of times</code></dd>
<dt>Vocabulary, <span class="underline">V</span></dt><dd>e.g. <code>[aardvark, ..., zither]</code></dd>
<dt>Bag of words: <span class="underline">X</span></dt><dd>[2, &#x2026;, 1]</dd>
<dt>Size of <span class="underline">X</span></dt><dd>\(1 \times d\) (\(d\) = vocabulary size)</dd>
</dl>
<p>
Hence \(n\) documents can be represented by matrix of size \(n \times d\).
</p>
</div>
<div id="outline-container-orgc799c0d" class="outline-4">
<h4 id="orgc799c0d"><span class="section-number-4">2.5.1.</span> Advantages and disadvantages</h4>
<div class="outline-text-4" id="text-2-5-1">
<ul class="org-ul">
<li>Advantages: easy to implement</li>
<li>Disadvantages:
<ul class="org-ul">
<li>Not scalable for large vocabulary</li>
<li>high dimensional sparse matrix results in expensive memory + computation</li>
<li>Order of words is disregarded; <b><b>no meaning</b></b> from context</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgcda748f" class="outline-3">
<h3 id="orgcda748f"><span class="section-number-3">2.6.</span> TF-IDF (Term Frequency-Inverse Document Frequency)</h3>
<div class="outline-text-3" id="text-2-6">
</div>
<div id="outline-container-org6dd5044" class="outline-4">
<h4 id="org6dd5044"><span class="section-number-4">2.6.1.</span> Why needed?</h4>
<div class="outline-text-4" id="text-2-6-1">
<ul class="org-ul">
<li>BoW does not provide logical importance
<ul class="org-ul">
<li>i.e., each word is equally important</li>
</ul></li>
<li>TF-IDF assigns more logical importance to words in each document</li>
</ul>
</div>
</div>
<div id="outline-container-org1abb98a" class="outline-4">
<h4 id="org1abb98a"><span class="section-number-4">2.6.2.</span> What is TF-IDF and when to use TF-IDF</h4>
<div class="outline-text-4" id="text-2-6-2">
<dl class="org-dl">
<dt>Definition of TF-IDF</dt><dd>a word's <b><b>importance score</b></b> in a document among \(N\) documents</dd>
<dt><span class="underline">N</span></dt><dd>total number of documents</dd>
<dt>Word count</dt><dd>likely TF-IDF</dd>
<dt>Term frequency, <span class="underline">TF</span></dt><dd>the number of times a word appears in <b><b>a document</b></b>.
TF is high if word appears many times in document, e.g. <span class="underline">the</span>, <span class="underline">a</span>, etc.</dd>
<dt>Inverse document frequency, <span class="underline">IDF</span></dt><dd>\(\log(\frac{N}{\text{number of docs containing the term}})\).
If all (or most) documents contain that term, then IDF will be <b><b>very small</b></b></dd>
<dt>Word's importance score</dt><dd>\(TF \times IDF\).
Higher score = more "characteristic"</dd>
</dl>
</div>
</div>
<div id="outline-container-orgd84327a" class="outline-4">
<h4 id="orgd84327a"><span class="section-number-4">2.6.3.</span> Advantages and disadvantages</h4>
<div class="outline-text-4" id="text-2-6-3">
<ul class="org-ul">
<li>Advantages:
<ul class="org-ul">
<li>Easy to implement</li>
<li>Higher score = "more characteristic". Common words will have very small scores.</li>
<li>Good technique to search for documents, find similar documents, cluster documents</li>
</ul></li>
<li>Disadvantages
<ul class="org-ul">
<li>Does not consider position of words when creating matrix. Similar problem as with BoW.</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org2bba7e2" class="outline-2">
<h2 id="org2bba7e2"><span class="section-number-2">3.</span> Week 3: Linear Text Classification</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org8297dd8" class="outline-3">
<h3 id="org8297dd8"><span class="section-number-3">3.1.</span> Classification introduction</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Note: <b><b>classification</b></b>.
</p>
</div>
<div id="outline-container-orge6fb61c" class="outline-4">
<h4 id="orge6fb61c"><span class="section-number-4">3.1.1.</span> Supervised learning: definitions</h4>
<div class="outline-text-4" id="text-3-1-1">
<dl class="org-dl">
<dt>Word count matrix / document term matrix</dt><dd>dataset generated from documents</dd>
<dt>Rows of matrix</dt><dd>each row is 1 document</dd>
<dt>Columns of matrix</dt><dd>each column is 1 unique word</dd>
<dt>Unique words: synonyms</dt><dd>features, dimensions, attributes, variables, columns</dd>
<dt>Documents: synonyms</dt><dd>rows, data points, instances</dd>
<dt>Model weights</dt><dd>= model parameters, i.e. what the model learns</dd>
<dt>Function \(F\)</dt><dd>maps \(X\) to \(Y\)</dd>
<dt>Training data \((x_i, y_i)\)</dt><dd>within set of \({X \times Y}\)</dd>
<dt>Learning - find \(\hat{f}\)</dt><dd>\(\hat{f} \in F\) s.t. \(y_i \approx \hat{f} (x_i)\)</dd>
<dt>New data</dt><dd>\(x\)</dd>
<dt>Prediction \(y\)</dt><dd>\(= \hat{f} (x)\)</dd>
</dl>

<p>
Supervised learning thus takes <b><b>labelled</b></b> training data and <b><b>learns</b></b> or <b><b>derives</b></b> a function \(f(x): y = f(x)\).
</p>
</div>
</div>

<div id="outline-container-org51cbea7" class="outline-4">
<h4 id="org51cbea7"><span class="section-number-4">3.1.2.</span> Categories of supervised learning</h4>
<div class="outline-text-4" id="text-3-1-2">
<dl class="org-dl">
<dt>continuous \(y\)</dt><dd>regression i.e. curve fitting</dd>
<dt>discrete \(y\)</dt><dd>classification i.e. class estimation</dd>
</dl>
</div>
</div>

<div id="outline-container-org104a806" class="outline-4">
<h4 id="org104a806"><span class="section-number-4">3.1.3.</span> Regression</h4>
<div class="outline-text-4" id="text-3-1-3">
<ul class="org-ul">
<li>Errors represent how much predictions deviate from actual values.</li>
<li>Minimum error = 0, however beware of overfitting, where test errors will be high (trained model cannot generalize).</li>
<li>Example: apartment rent prediction, stock price prediction (difficult due to many predictors, known and unknown).</li>
</ul>
</div>
</div>

<div id="outline-container-org95da91b" class="outline-4">
<h4 id="org95da91b"><span class="section-number-4">3.1.4.</span> Classification</h4>
<div class="outline-text-4" id="text-3-1-4">
<ul class="org-ul">
<li>Linear classification can be used for spam detection, sentiment analysis, handwriting digit recognition (0.4% error here), etc.</li>
<li>Prepare, clean data, fit a classifier</li>
<li>Retraining is required due to new evolving context, new lingo, etc. Can be implemented into a learning system.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org0cdba92" class="outline-3">
<h3 id="org0cdba92"><span class="section-number-3">3.2.</span> Naive Bayes</h3>
<div class="outline-text-3" id="text-3-2">
</div>
<div id="outline-container-orgfb8cadd" class="outline-4">
<h4 id="orgfb8cadd"><span class="section-number-4">3.2.1.</span> Method / concepts</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
Bayes Decision Rule.
</p>
<dl class="org-dl">
<dt>\(x\)</dt><dd>encoded document, e.g. by BoW</dd>
<dt>\(y\)</dt><dd>label of document, i.e. whether document contains positive or negative message</dd>
<dt>Posterior</dt><dd>\(P(y|x)\)</dd>
<dt>Likelihood</dt><dd>\(P(x|y)\)</dd>
<dt>Prior</dt><dd>\(P(y)\)</dd>
<dt>Normalization constant</dt><dd>\(P(x)\)</dd>
</dl>

<p>
\[
P(y|x) = \frac{P(x|y)P(y)}{P(x)} = \frac{P(x,y)}{\sum_y P(x,y)}
\]
</p>
</div>
</div>
<div id="outline-container-org7f83586" class="outline-4">
<h4 id="org7f83586"><span class="section-number-4">3.2.2.</span> Bayes decision rule</h4>
<div class="outline-text-4" id="text-3-2-2">
<ul class="org-ul">
<li><span style='background-color: #FFFF00;'>important</span>: normalization constant is the same for +ve and -ve labels, hence no need to calculate when predicting sentiment</li>
</ul>
</div>
</div>
<div id="outline-container-org846dcd4" class="outline-4">
<h4 id="org846dcd4"><span class="section-number-4">3.2.3.</span> Generative vs discriminative models</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
Naive Bayes is a generative model
</p>
<ul class="org-ul">
<li>Generative model: able to generate synthetic data points
<ul class="org-ul">
<li><b><b>Need</b></b> to model prior and likelihood distributions.</li>
<li>In Naive Bayes, we normally replace likelihood with the conditional distribution.</li>
<li>Conditional distribution is the pdf/pmf to generate data points.
<ul class="org-ul">
<li>Determining this distribution might be difficult.</li>
</ul></li>
<li>Generative models e.g.: Naive Bayes, Hidden Markov Models</li>
</ul></li>
<li>Discriminative models:
<ul class="org-ul">
<li>Directly estimate posteriors</li>
<li>No need to model prior and likelihood distributions</li>
<li>e.g.: logistic regression, SVM, neural networks</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org130cad8" class="outline-4">
<h4 id="org130cad8"><span class="section-number-4">3.2.4.</span> Details of Naive Bayes</h4>
<div class="outline-text-4" id="text-3-2-4">
<p>
Bayes decision rule:
\[
P(y|x) = \frac{P(x|y)P(y)}{P(x)}
\]
</p>
<ul class="org-ul">
<li><span style='background-color: #FFFF00;'>assumption</span>: all dimensions (unique words) are independent of each other, i.e. \(p(x|y = 1)\) fully factorized, hence: \(P(x|y=1) = \prod^d_{i=1} P(x_i|y = 1)\)
<ul class="org-ul">
<li>Thus, likelihood can be written in fully factorized way.</li>
<li>It becomes a big joint probability of all unique words (dimensions).</li>
<li>Conditional independence, hence likelihood can be written as multiplication of every dimension given the label.</li>
<li>i.e., the variables corresponding to each dimension are independent given the label.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org039943e" class="outline-4">
<h4 id="org039943e"><span class="section-number-4">3.2.5.</span> Naive Conditional Independence Assumption</h4>
<div class="outline-text-4" id="text-3-2-5">
<p>
\[
P(y|x) = \frac{P(x|y)P(y)}{P(x)}
\]
</p>

<p>
For vocabulary \(V\), <code>[nice, give, us, this, iu, ssn, information, job, a]</code>
</p>

<p>
\(P(\text{document} | y = \text{positive})P(y=\text{positive})\)
</p>

<p>
= \(P(x=\text{nice}) ... P(x=a|y=\text{positive})\) \(\cdot P(y= \text{positive})\)
</p>

<p>
similarly for negatives:
</p>

<p>
\(P(\text{document} | y = \text{negative})P(y=\text{negative})\)
</p>

<p>
= \(P(x=\text{nice}) ... P(x=a|y=\text{negative})\) \(\cdot P(y= \text{negative })\)
</p>
</div>
<ol class="org-ol">
<li><a id="org4091a78"></a>Representing the likelihood<br />
<div class="outline-text-5" id="text-3-2-5-1">
<p>
Common distribution: <b><b>multinomial distribution</b></b>.
</p>

<p>
\[
P(x=\text{nice} | y = \text{positive})
\]
</p>

<p>
\[
= \frac{\text{count of word }\textbf{nice} \text{ in all positive label docs }}{\text{count all words with } \textbf{positive}  \text{  labels}}
\]
</p>

<p>
Then to calc priors:
</p>

<p>
\[
P(y = \text{positive}) = \frac{\text{count # +ve docs}}{\text{count # all docs}}
\]
</p>

<p>
Repeat above for negatives.
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgfb4f08b" class="outline-4">
<h4 id="orgfb4f08b"><span class="section-number-4">3.2.6.</span> Advantages and disadvantages</h4>
<div class="outline-text-4" id="text-3-2-6">
<ul class="org-ul">
<li>Advantages
<ul class="org-ul">
<li>Simple, easy to implement</li>
<li>No training required</li>
<li>Good results in general</li>
</ul></li>
<li>Disadvantages
<ul class="org-ul">
<li>Position of words do not matter (no semantic meaning) due to BoW approach</li>
<li>Requires / assumes conditional independence</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org6c79fa8" class="outline-3">
<h3 id="org6c79fa8"><span class="section-number-3">3.3.</span> Classification Model Evaluation</h3>
<div class="outline-text-3" id="text-3-3">
</div>
<div id="outline-container-org1e69e11" class="outline-4">
<h4 id="org1e69e11"><span class="section-number-4">3.3.1.</span> Common metrics</h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li>Classification: accuracy, precision, recall, cross-entropy, perplexity, and F1 score</li>
<li>Regression: MSE, MAE</li>
</ul>
</div>
</div>
<div id="outline-container-orgc1f3cde" class="outline-4">
<h4 id="orgc1f3cde"><span class="section-number-4">3.3.2.</span> Confusion matrix</h4>
<div class="outline-text-4" id="text-3-3-2">
<ul class="org-ul">
<li>e.g. for multi-label confusion matrix</li>
<li>rows are the actual classes (sport, news politics)</li>
<li>columns are the predicted classes</li>
<li>diagonal elements are number of accurate predictions</li>
<li>off-diagonals: inaccurate predictions</li>
<li>But difficult to parse, can consider using a heat map on the confusion matrix instead of raw #</li>
<li><span style='background-color: #FFFF00;'>meaning of positive and negative in a confusion matrix</span>: not related to sentiment. Only indicator of the label, e.g. sport = positive, news = negative.</li>
</ul>
</div>
</div>
<div id="outline-container-org32d3a38" class="outline-4">
<h4 id="org32d3a38"><span class="section-number-4">3.3.3.</span> Accuracy</h4>
<div class="outline-text-4" id="text-3-3-3">
<ul class="org-ul">
<li>Accuracy = (True Positive + True Negative) / Total observations, i.e. sum of diagonals / count observations.</li>
<li>May not be represent "goodness" since false positives and false negatives have identical treatment.</li>
<li>FP and FN may be important specifically for some fields e.g. medicine.</li>
<li>Another metric, false alarm (false positive, type I error) is easy to remember in security contexts.</li>
</ul>
</div>
</div>
<div id="outline-container-orgb9df380" class="outline-4">
<h4 id="orgb9df380"><span class="section-number-4">3.3.4.</span> RoC-AUC curve</h4>
<div class="outline-text-4" id="text-3-3-4">
<ul class="org-ul">
<li>ROC: Receiver Operating Characteristic</li>
<li>Changing thresholds: how to change, what should the new threshold be?</li>
<li>TP (y-axis) vs FP (x-axis)</li>
<li>AUC (area under the curve) represents the how performant the predictive model is. Max is 1.0.</li>
<li>But 0.9 may not be good either.
<ul class="org-ul">
<li>Are there some thresholds where TP = 0? Are these important in the context?</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org9e706dc" class="outline-2">
<h2 id="org9e706dc"><span class="section-number-2">4.</span> Week 5: Log Regression, SVM and Perceptron (Module 4)</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgfd08760" class="outline-3">
<h3 id="orgfd08760"><span class="section-number-3">4.1.</span> Logistic Regression</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>Backbone of neural network model</li>
<li>Created on linear combination of features</li>
<li>Outputs a <b>probability</b>
<ul class="org-ul">
<li>Logistic regression is thus a <b>soft classification</b></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org6191f36" class="outline-4">
<h4 id="org6191f36"><span class="section-number-4">4.1.1.</span> Generative vs Discriminative Models (again)</h4>
<div class="outline-text-4" id="text-4-1-1">
<ul class="org-ul">
<li>Generative model: able to generate synthetic data points
<ul class="org-ul">
<li><b><b>Need</b></b> to model prior and likelihood distributions.</li>
<li>Conditional distribution is the pdf/pmf to generate data points.
<ul class="org-ul">
<li>Determining this distribution might be difficult.</li>
</ul></li>
<li>Generative models e.g.: Naive Bayes, Hidden Markov Models (HMM)</li>
</ul></li>
<li>Discriminative models:
<ul class="org-ul">
<li>Directly estimate posteriors</li>
<li>No need to model prior and likelihood distributions</li>
<li>e.g.: logistic regression, SVM, neural networks</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orga8008ca" class="outline-4">
<h4 id="orga8008ca"><span class="section-number-4">4.1.2.</span> Bayes equation again</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
\[
P(y|x) = \frac{P(x|y)P(y)}{P(x)} = \frac{P(x,y)}{\sum_y P(x,y)}
\]
</p>
<dl class="org-dl">
<dt>Generative models</dt><dd>need to calculate likelihood and prior explicitly</dd>
<dt>Discriminative models</dt><dd>can we calculate posterior directly without using Bayes equation?</dd>
</dl>
</div>
</div>
<div id="outline-container-org860620c" class="outline-4">
<h4 id="org860620c"><span class="section-number-4">4.1.3.</span> Logistic Function for posterior probability</h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
i.e. the following function
</p>

<p>
\[
P(y|x) = g(s) = \frac{e^s}{1+e^s} = \frac{1}{1+e^{-s}}
\]
</p>

<ul class="org-ul">
<li>This function is known as the <b><b>sigmoid function</b></b>.</li>
<li>Easy to use this for optimization</li>
<li>Threshold: always 0.5?
<ul class="org-ul">
<li>Threshold can be investigated with ROC-AUC to determine best threshold</li>
</ul></li>
<li>Neural network with just 1 block is similar to logistic regression</li>
<li>Logistic regression: sigmoid is the activation function</li>
</ul>


<div id="org3957d23" class="figure">
<p><img src="./img/sigmoid.png" alt="sigmoid.png" />
</p>
</div>

<ul class="org-ul">
<li>Three linear models with different activation functions
<ul class="org-ul">
<li>Using a <b><b>sine</b></b> activation function: it will be transformed to perceptron, a hard classification</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org96bd956" class="outline-4">
<h4 id="org96bd956"><span class="section-number-4">4.1.4.</span> Sigmoid is interpreted as probability</h4>
<div class="outline-text-4" id="text-4-1-4">
<ul class="org-ul">
<li><p>
e.g., does a customer like a product based on feedback?
</p>
<ul class="org-ul">
<li>Input: \(x\) a BoW or TF-IDF of a document that contains customer's feedback</li>
<li>\(g(s)\) is the probability of whether a customer likes a product</li>
<li>Cannot have hard prediction or classification here</li>
</ul>
\begin{equation}
s = x\theta \text{ the risk score} \\
h_\theta (x) = p(y|x) =
\begin{cases}
g(s) & y=1 \\
1-(gs) & y=0 \text{ using posterior probability directly}
\end{cases}
\end{equation}</li>
<li>Sigmoid is the inverse of <b>logit</b> function (or the log-odds ratio)</li>
</ul>
</div>
</div>
<div id="outline-container-org40913b0" class="outline-4">
<h4 id="org40913b0"><span class="section-number-4">4.1.5.</span> Logistic regression model</h4>
<div class="outline-text-4" id="text-4-1-5">
<ul class="org-ul">
<li>Expanding equation and replacing \(g(s)\) with linear combination of features</li>
<li>Probabilistic model</li>
<li>Uses MLE to optimize linear combination of features</li>
<li>Use log-likelihood for better numerical stability</li>
<li><p>
To find &theta; parameters, for \(n\) data points:
</p>
\begin{equation}
P(y|x) =
\begin{cases}
\frac{1}{1+ \exp(-x\theta)} & y=1 \\
1-\frac{1}{1+\exp(-x\theta)} = \frac{\exp(-x\theta)}{1+\exp(-x\theta)} & y=0
\end{cases}
\end{equation}</li>
</ul>
</div>
</div>
<div id="outline-container-org2fa29aa" class="outline-4">
<h4 id="org2fa29aa"><span class="section-number-4">4.1.6.</span> The gradient of \(l(\theta)\)</h4>
<div class="outline-text-4" id="text-4-1-6">
<p>
\[
l(\theta) := \log \prod^n_{i=1} p(y_i, |x_i, \theta) \\
= \sum_i \theta^T x_i^T (y_i -1) - \log(1+\exp(-x_i \theta))
\]
<b><b>Gradient</b></b>:
\[
\frac{\partial l(\theta)}{\partial \theta} =
\sum_i x_i^T (y_i-1) + x_i^T \frac{\exp(-x_i \theta)}{1+\exp(-x_i \theta)}
\]
</p>
<ul class="org-ul">
<li>Even when set to 0, there is <b><b>no</b></b> closed-form solution.
<ul class="org-ul">
<li>Even though there is a global solution</li>
<li>Unlike linear regression where there is a closed-form solution</li>
<li>Hence, logistic regression is unconstrained, but</li>
<li>Can optimize using iterative approach such as gradient descent</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org513759f" class="outline-4">
<h4 id="org513759f"><span class="section-number-4">4.1.7.</span> Gradient descent</h4>
<div class="outline-text-4" id="text-4-1-7">
<ul class="org-ul">
<li>One way to solve unconstrained optimization problem is gradient descent</li>
<li>Given initial guess, we iteratively refine the guess by taking the direction of the <span style='background-color: #FFFF00;'>negative gradient</span></li>
<li>Analogous to going down the hill by taking steepest direction at each step</li>
<li>Update rule
\[
  x_{k+1} = x_k - \eta_k \nabla f(x_k)
  \]
\(\eta_k\) is the <span style='background-color: #FFFF00;'>step size or learning rate</span></li>
<li>Step taken should be small enough</li>
</ul>
</div>
</div>
<div id="outline-container-orgb6aa5c1" class="outline-4">
<h4 id="orgb6aa5c1"><span class="section-number-4">4.1.8.</span> Gradient ascent (concave) / descent (convex) algorithm</h4>
<div class="outline-text-4" id="text-4-1-8">
<ul class="org-ul">
<li>Initialize parameter \(\theta_0\)</li>
<li>Do:
\[
  \theta_{t+1} \leftarrow \theta^t + \eta \sum_i x_i^T (y_i-1) + x_i^T \frac{\exp(-x_i \theta)}{1+\exp(-x_i \theta)}
  \]</li>
<li>while:
\[
  \parallel \theta^{t+1} - \theta^t \parallel > \epsilon
  \]</li>
<li>ascent: maximize function</li>
<li>descent: minimize</li>
<li>Thus:
<ul class="org-ul">
<li>Logical threshold = 0.5, i.e. predict 1 if \(g(s) \ge 0.5\)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org57289bd" class="outline-4">
<h4 id="org57289bd"><span class="section-number-4">4.1.9.</span> Advantages and disadvantages of logistic regression</h4>
<div class="outline-text-4" id="text-4-1-9">
<ul class="org-ul">
<li>Advantages:
<ul class="org-ul">
<li>Simple</li>
<li>No need to model prior or likelihood</li>
<li>Provides probability output</li>
<li>Works with datasets with few features</li>
</ul></li>
<li>Disadvantages:
<ul class="org-ul">
<li>Needs to have discriminative model assumption</li>
<li>Model needs to be optimized using numerical approach</li>
<li>Might not work with complicated dataset</li>
</ul></li>
</ul>
<p>
**
</p>
</div>
</div>
</div>
<div id="outline-container-orgccb7a9b" class="outline-3">
<h3 id="orgccb7a9b"><span class="section-number-3">4.2.</span> Support vector machine</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>SVM is a large margin classifier</li>
</ul>
</div>
<div id="outline-container-org5beac23" class="outline-4">
<h4 id="org5beac23"><span class="section-number-4">4.2.1.</span> Linear separation</h4>
<div class="outline-text-4" id="text-4-2-1">
<ul class="org-ul">
<li>Can have different separating lines, so which line is the best?
<ul class="org-ul">
<li>Why is having bigger margin better?</li>
<li>What &theta; maximizes margin?</li>
</ul></li>
</ul>

<div id="org5938ee6" class="figure">
<p><img src="./img/lin-sep.png" alt="lin-sep.png" />
</p>
</div>
<ul class="org-ul">
<li>All cases, error is zero and they are linear, so they are all good for generalization.</li>
<li>SVM focuses on just one solution (compared to perceptron) and that's the maximum margin solution</li>
<li>SVM maximizes margin and provides decision line with maximized margin, which is the <span style='background-color: #FFFF00;'>most stable</span> under perturbations of inputs</li>
</ul>
</div>
</div>
<div id="outline-container-orgde23dbc" class="outline-4">
<h4 id="orgde23dbc"><span class="section-number-4">4.2.2.</span> Finding &theta; that maximizes margin</h4>
<div class="outline-text-4" id="text-4-2-2">
<ul class="org-ul">
<li>Objective function created by constructing linear combination of features.
<ul class="org-ul">
<li>Solution (decision boundary) of the line
\[
    x \theta = 0
    \]</li>
<li>Let \(x_i\) be the nearest data point to the line/plane</li>
<li>Decision boundary is thus \(x\theta + b = 0\)
<ul class="org-ul">
<li>Below decision line: &le; 0</li>
<li>Above decision line: &ge; 0</li>
</ul></li>
<li>Scaling up / down &theta; thus allows you to set the nearest point to \(1\).</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org00ec0a2" class="outline-4">
<h4 id="org00ec0a2"><span class="section-number-4">4.2.3.</span> Length of margin</h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
\[
\text{distance} = \frac{1}{\parallel \theta \parallel} |(x_i \theta - x \theta)|
= \frac{1}{\parallel \theta \parallel}|(x_i \theta + b - x\theta -b)|
\]
where:
</p>
<dl class="org-dl">
<dt>\(x_i \theta + b\)</dt><dd>my constraint \(\equiv |x_i \theta + b| = 1\)</dd>
<dt>\(-x\theta - b\)</dt><dd>a point on the decision line \(\equiv x\theta + b = 0\)</dd>
</dl>

<p>
Therefore total margin is: \(\frac{2}{\parallel \theta \parallel}\) (since there are 2 points on each side of the decision line)
</p>


<div id="orga96f1e0" class="figure">
<p><img src="./img/large-margin.png" alt="large-margin.png" />
</p>
</div>

<ul class="org-ul">
<li>&theta; is <span style='background-color: #FFFF00;'>orthogonal</span> to the decision line</li>
</ul>
</div>
</div>
<div id="outline-container-orgfc85400" class="outline-4">
<h4 id="orgfc85400"><span class="section-number-4">4.2.4.</span> Maximizing margin</h4>
<div class="outline-text-4" id="text-4-2-4">
<ul class="org-ul">
<li>Maximize \(\frac{2}{\parallel \theta \parallel}\) in the objective function</li>
<li>Subject to \(\min_{i=1,2,...,N} |x_i \theta + b| = 1\) which is the nearest neighbour, sign-agnostic for labels here, hence absolute.</li>
<li>Hard to optimize this due to the "min" in the constraint (non-convex form)</li>
<li>To get rid of the absolute value in the constraint, (and to get the correct prediction, predicted value must have same sign as actual)
\[
  \left|x_i \theta + b\right| = y_i(x_i \theta + b) \rightarrow \text{for correct classification} \\
  \text{ if} \min |x_i \theta + b | = 1 \rightarrow \text{ it can be at least 1}
  \]</li>
<li>Hence,
\[
  \max \frac{2}{\parallel \theta \parallel}
  \\
  \text{subject to } y_i (x_i \theta + b) \ge 1 \text{ for } i=1,2,...,N
  \]</li>
</ul>
</div>
</div>
<div id="outline-container-org16dc312" class="outline-4">
<h4 id="org16dc312"><span class="section-number-4">4.2.5.</span> Geometric representation</h4>
<div class="outline-text-4" id="text-4-2-5">

<div id="org11cc351" class="figure">
<p><img src="./img/geom-rep.png" alt="geom-rep.png" />
</p>
</div>
<dl class="org-dl">
<dt>Decision line</dt><dd>\(x\theta + b = 0\)</dd>
<dt>Margin line</dt><dd>\(x \theta + b = 1\)</dd>
<dt>Blue colors</dt><dd>constraint (data points beyond margin line); beyond margin line the margin &ge; 1, correctly classified</dd>
</dl>
</div>
<ol class="org-ol">
<li><a id="org7ab4fbe"></a>Converting problem<br />
<div class="outline-text-5" id="text-4-2-5-1">
<ul class="org-ul">
<li>Many ML libraries can solve minimization problems instead of maximization</li>
<li>Hence, convert from:
\[
  \max(\frac{2}{\parallel \theta \parallel}) \\
  \text{subject to } y_i (x_i \theta + b) \ge 1 \text{ for }i=1,2,...,N
  \]</li>
<li>to:
\[
  \min(\frac{1}{2} \theta\theta^T) \\
  \text{subject to } y_i (x_i \theta + b) \ge 1 \text{ for }i=1,2,...,N
  \]</li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-org15cc892" class="outline-4">
<h4 id="org15cc892"><span class="section-number-4">4.2.6.</span> Lagrange formulation (not in detail)</h4>
<div class="outline-text-4" id="text-4-2-6">
<p>
\[
\min(\frac{1}{2} \theta\theta^T) \\
\text{subject to } y_i (x_i \theta + b) -1 \ge 0  \\
\textit{L}(\theta, b, \alpha) = \frac{1}{2}\theta\theta^T - \sum^N_{i=1} \alpha_i (y_i(x_i \theta + b)-1)
\]
becomes:
\[
\min \text{w.r.t. } \theta, b \text{ and } \max \text{w.r.t. each } \alpha_i \ge 0 \\
\nabla_\theta L(\theta, b, \alpha) = \theta - \sum^N_{i=1} \alpha_i y_i x_i = 0 \\
\nabla_b L(\theta, b, \alpha) = -sum^N{i=1} \alpha_i y_i = 0
\]
under KKT conditions,
where:
</p>
<dl class="org-dl">
<dt>\(\theta\)</dt><dd>model parameter</dd>
<dt>\(b\)</dt><dd>bias term</dd>
<dt>\(\alpha\)</dt><dd>Lagrange multiplier</dd>
</dl>
<p>
Need to convert primal form to dual form.
Take gradient w.r.t. &theta;, b, set to 0.
Calculate parametric value of &theta; and new constraints.
Convert objective function to dual form.
\[
\theta = \sum^N_{i=1} \alpha_i y_i x_i \text{ and } \sum^N_{i=1} \alpha_i y_i = 0 \\
L(\theta, b, \alpha) = \sum^N{i=1} \alpha_i - \frac{1}{2} \theta \theta^T \\
L(\theta, b, \alpha) = \sum^N_{i=1} \alpha_i - \frac{1}{2} \sum^N_{i=1} \sum^N_{j=1} y_i y_j \alpha_i \alpha_j x_i x_j^T
\\
\max \text{ w.r.t. each } \alpha_i \ge 0 \text{ for }i=1,...,N \text{ and }
\sum^N_{i=1} \alpha_i y_i = 0
\]
</p>
</div>
</div>
<div id="outline-container-orgb73180a" class="outline-4">
<h4 id="orgb73180a"><span class="section-number-4">4.2.7.</span> Usage</h4>
<div class="outline-text-4" id="text-4-2-7">
<ul class="org-ul">
<li>Dual form good for binary classification, e.g. spam or not spam.</li>
<li>Training
\[
  \theta = \sum^N_{i=1} \alpha_i y_i x_i
  \]
<ul class="org-ul">
<li>No need to go over all data points</li>
<li>\[
    \rightarrow \theta = \sum_{x \in \text{ SV}} \alpha_i y_i x_i
    \]</li>
<li>and for \(b\) pick any support vector, and calculate \(y_i (x_i \theta + b) = 1\)</li>
</ul></li>
<li>Testing
<ul class="org-ul">
<li>For new point \(s\), compute:
\[
    s \theta + b = \sum_{x_i \in \text{ SV}} \alpha_i y_i x_i s^T + b
    \]</li>
<li>Classify \(s\) as class 1 if positive, else classify as class 2.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orga2c5eca" class="outline-4">
<h4 id="orga2c5eca"><span class="section-number-4">4.2.8.</span> From \(x\) to \(z\) space</h4>
<div class="outline-text-4" id="text-4-2-8">
<ul class="org-ul">
<li>SVM can only be used when a linear decision line can be used</li>
<li>Sometimes it may be possible to work around by moving from Cartesian to Polar space</li>
<li>Not necessarily applicable to NLP since there are many many dimensions.</li>
<li>Instead, kernel trick can be utilised in the dual form model, do feature engineering and handle millions of features.</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="orgb20a42f"></a>Kernel trick<br />
<div class="outline-text-5" id="text-4-2-8-1">
<p>
Main premise is to take data from original space to newer space with higher dimensions, which make it more likely to have linear separation in the newer space.
</p>

<p>
In \(x\) space, they are called pre-images of support vectors.
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-org280489d" class="outline-4">
<h4 id="org280489d"><span class="section-number-4">4.2.9.</span> Support vector machine</h4>
<div class="outline-text-4" id="text-4-2-9">
<ul class="org-ul">
<li>Can do <span style='background-color: #FFFF00;'>either</span>
<ul class="org-ul">
<li>Hard classification</li>
<li>Soft classification</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org4e8b7b8" class="outline-3">
<h3 id="org4e8b7b8"><span class="section-number-3">4.3.</span> Perceptron</h3>
<div class="outline-text-3" id="text-4-3">

<div id="orgc08048c" class="figure">
<p><img src="./img/spam.png" alt="spam.png" />
</p>
</div>
<ul class="org-ul">
<li>Needs to be linearly separable to work</li>
<li>Can be used for text classification, sentiment analysis</li>
<li><p>
Given training data \((x_i, y_i)\) for \(i = 1,...,N, x_i \in \mathbb{R}^d \text{ and }y_i \in {-1,1}\) learn a classifier \(f(x)\) such that
</p>
\begin{equation}
f(x_i)
\begin{cases}
\ge 0 & +1 & \text{Non-spam document} \\
\lt 0 & -1 & \text{Spam document}
\end{cases}
\end{equation}</li>
<li>i.e. \(y_i f(x_i) \gt 0\) for a correct classification</li>
</ul>
</div>
<div id="outline-container-orgd23534f" class="outline-4">
<h4 id="orgd23534f"><span class="section-number-4">4.3.1.</span> Linearly separable</h4>
<div class="outline-text-4" id="text-4-3-1">

<div id="org414bc7e" class="figure">
<p><img src="./img/linear-sep.png" alt="linear-sep.png" />
</p>
</div>
<ul class="org-ul">
<li>The two labels must be separable by a <b><b>straight</b></b> line</li>
<li>Perceptron uses linear classifier, as it uses linear combination of features</li>
</ul>
</div>
</div>
<div id="outline-container-orgd6b74cf" class="outline-4">
<h4 id="orgd6b74cf"><span class="section-number-4">4.3.2.</span> Linear classifier</h4>
<div class="outline-text-4" id="text-4-3-2">
<p>
<img src="./img/lin-class.png" alt="lin-class.png" />
Linear classifier has the form
\[
f(x) = x\theta + \theta_0
\]
</p>
<ul class="org-ul">
<li>In 2D, the discriminant is a line</li>
<li>\(\theta\) is the <b><b>normal</b></b> to the decision line</li>
<li>\(\theta_0\), is the bias term</li>
<li>\(\theta\) is known as the model <span style='background-color: #FFFF00;'>parameter</span> or the <span style='background-color: #FFFF00;'>weight vector</span></li>
<li>Decision boundary has \(d-1\) dimensions where \(d\) is the number of features</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="orgd9d454a"></a>Linear classifier for higher dimensions<br />
<div class="outline-text-5" id="text-4-3-2-1">
<ul class="org-ul">
<li>In 3D, the discriminant is a plane</li>
<li>in nD, the discriminant is a hyperplane</li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-org8baa2ea" class="outline-4">
<h4 id="org8baa2ea"><span class="section-number-4">4.3.3.</span> The Perceptron Classifier</h4>
<div class="outline-text-4" id="text-4-3-3">
<ul class="org-ul">
<li><span style='background-color: #FFFF00;'>hard classifier</span></li>
<li>Considering \(x\) is linearly separable</li>
<li>\(y\) has 2 labels \(\{-1,1 \}\)</li>
<li>\(f(x_i) = x_i \theta\), where bias is inside \(\theta\)</li>
<li>How to separate data points with label 1 from those with -1 using a <b><b>line</b></b>?</li>
<li>Perceptron classifier is a simple for-loop
<ul class="org-ul">
<li>Goes inside every single data point to check whether it's classified correctly</li>
</ul></li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org20145c3"></a>Algorithm<br />
<div class="outline-text-5" id="text-4-3-3-1">

<div id="orge232971" class="figure">
<p><img src="./img/perceptron.png" alt="perceptron.png" />
</p>
</div>
<ol class="org-ol">
<li>Initialise \(\theta = 0\)</li>
<li>Go through each data point \(\{x_i, y_i \}\)
<ol class="org-ol">
<li>If \(x_i\) is misclassified, then \(\theta^{t+1} \leftarrow \theta^t + \alpha y_i x_i\) (i.e. moving the decision line towards the correct label)</li>
</ol></li>
<li>Until all data points are correctly classified</li>
</ol>
</div>
</li>
</ol>
</div>
<div id="outline-container-org7ec7ee9" class="outline-4">
<h4 id="org7ec7ee9"><span class="section-number-4">4.3.4.</span> Perceptron activation</h4>
<div class="outline-text-4" id="text-4-3-4">

<div id="org4d60713" class="figure">
<p><img src="./img/perceptron-activation.png" alt="perceptron-activation.png" />
</p>
</div>
<ul class="org-ul">
<li>LHS = number of lines = number of features</li>
<li>output of linear combination of features, \(f(x)\) is real number,</li>
<li>fed into activation function in red, which is +1 or -1</li>
</ul>
</div>
</div>
<div id="outline-container-orgec86ac8" class="outline-4">
<h4 id="orgec86ac8"><span class="section-number-4">4.3.5.</span> Advantages and disadvantages of Perceptron</h4>
<div class="outline-text-4" id="text-4-3-5">
<ul class="org-ul">
<li>Advantages
<ul class="org-ul">
<li>Very simple</li>
<li>Fast, does not require any parameters</li>
<li>Quick training to optimize parameters</li>
</ul></li>
<li>Disadvantages
<ul class="org-ul">
<li>Works only for linearly separable data</li>
<li>Does not provide unique decision boundary</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org93dce3c" class="outline-2">
<h2 id="org93dce3c"><span class="section-number-2">5.</span> Week 6: Embeddings/Dimensionality reduction</h2>
<div class="outline-text-2" id="text-5">
<p>
Singular Value Decomposition (SVD)
</p>
</div>
<div id="outline-container-orge7b8d48" class="outline-3">
<h3 id="orge7b8d48"><span class="section-number-3">5.1.</span> SVD and Co-occurrence Embeddings</h3>
<div class="outline-text-3" id="text-5-1">
</div>
<div id="outline-container-orgca3bb66" class="outline-4">
<h4 id="orgca3bb66"><span class="section-number-4">5.1.1.</span> Motivating example</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
Dimensionality reduction for text is to understand how they behave in 2D or 3D space.
</p>
<ul class="org-ul">
<li>This helps to get better perspective of the data.</li>
<li>High dimensionality data points happens on text and data problems due to many unique words.</li>
</ul>
</div>
</div>
<div id="outline-container-org7314391" class="outline-4">
<h4 id="org7314391"><span class="section-number-4">5.1.2.</span> Bag of words representation</h4>
<div class="outline-text-4" id="text-5-1-2">
<ul class="org-ul">
<li>Has many unique words (dimensions) that leads to:
<ul class="org-ul">
<li><b><b>overfitting</b></b></li>
<li>more resources &amp; time needed</li>
</ul></li>
<li>BoW generates a term-document matrix with many many features that's sparse</li>
<li>Possible solution: <b><b>dimension reduction</b></b></li>
</ul>
</div>
</div>
<div id="outline-container-orgd4c5eb7" class="outline-4">
<h4 id="orgd4c5eb7"><span class="section-number-4">5.1.3.</span> What is dimensionality reduction?</h4>
<div class="outline-text-4" id="text-5-1-3">

<div id="orgeed2fea" class="figure">
<p><img src="./img/dim-reduct.png" alt="dim-reduct.png" />
</p>
</div>
<ul class="org-ul">
<li>Dimensionality reduction is the process of reducing <b><b>random variables</b></b> under consideration</li>
<li>Possible approaches:
<ul class="org-ul">
<li>Combine, transform or select variables</li>
<li>With linear or non-linear operations</li>
</ul></li>
<li>New space has lower dimensions than previous space</li>
</ul>
</div>
</div>
<div id="outline-container-org08726ad" class="outline-4">
<h4 id="org08726ad"><span class="section-number-4">5.1.4.</span> Intuition (of PCA)</h4>
<div class="outline-text-4" id="text-5-1-4">
<ul class="org-ul">
<li>Approximate a \(D\) -dimensional dataset using fewer dimensions</li>
<li>By rotating the axes into a new space</li>
<li>Highest order dimension captures the most variance in the original dataset</li>
<li>Next dimension captures the next most variance, etc.</li>
<li>PCA uses eigendecomposition of covariance of dataset to maximize variance
<ul class="org-ul">
<li>Eigenvector corresponding to the highest eigenvalue is the new dimension that maximises the variance the most</li>
<li>Hope of PCA is that a dimension that explains variance the most would explain data better and it's easier to separate and distinguish labels when data points are spread out because of high variance</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org9a4eb54" class="outline-4">
<h4 id="org9a4eb54"><span class="section-number-4">5.1.5.</span> Singular value decomposition</h4>
<div class="outline-text-4" id="text-5-1-5">
<p>
For a matrix \(X_{n \times d}\) where:
</p>
<dl class="org-dl">
<dt>n</dt><dd>number of instances</dd>
<dt>d</dt><dd>dimension</dd>
</dl>

<p>
\[
X = U \Sigma V^T
\]
</p>

<dl class="org-dl">
<dt>U, &Sigma;, V</dt><dd>all unitary matrices</dd>
<dt>m columns</dt><dd>represent a dimension in a new latent space s.t. \(m\) column vectors are orthogonal to each other, and ordered by the amount of variance in the dataset in each dimension. \(m\) has <b><b>maximum</b></b> of \(d\) dimensions</dd>
<dt>\(U_{n \times m}\)</dt><dd>unitary matrix &rarr; \(UU^T = I\)</dd>
<dt>\(\Sigma_{m \times m}\)</dt><dd>diagonal matrix of singular values of \(X\)</dd>
<dt>\(V_{m \times d}\)</dt><dd>unitary matrix \(\rightarrow VV^T = I\)</dd>
</dl>
</div>
</div>
<div id="outline-container-org6ae4eb3" class="outline-4">
<h4 id="org6ae4eb3"><span class="section-number-4">5.1.6.</span> Co-occurrence matrices</h4>
<div class="outline-text-4" id="text-5-1-6">
<div class="BLOCKQUOTE" id="org13c0676">
<p>
Instead of matrix.
</p>

</div>
<p>
Each matrix for one value of context length.
</p>

<ul class="org-ul">
<li>Meaning of a word is defined by the words in its surroundings</li>
<li>Define a context window as the number of words appearing around a centre word</li>
<li>Create a co-occurrence matrix:
<ol class="org-ol">
<li>Go through each central word-context pair in corpus (context window length is commonly in \([1,5]\))</li>
<li>In each iteration, update the row of the count matrix (of central word) by adding +1 in the columns for the context words</li>
<li>Repeat last step many times</li>
</ol></li>
</ul>

<div id="org98c7485" class="figure">
<p><img src="./img/co-matrix.png " alt="co-matrix.png " />
</p>
</div>
</div>
</div>
<div id="outline-container-orgc33bfbe" class="outline-4">
<h4 id="orgc33bfbe"><span class="section-number-4">5.1.7.</span> SVD on co-occurrence matrices</h4>
<div class="outline-text-4" id="text-5-1-7">
<ul class="org-ul">
<li>For corpus with vocabulary \(V\) of size \(d\), co-occurrence matrix has size \(d \times d\)</li>
<li>Size of co-occurrence matrix increases with vocabulary</li>
<li>Instead of keeping all dimensions, can instead use truncated SVD to keep only to \(k\) singular values
<ul class="org-ul">
<li>e.g. \(k=300\)</li>
</ul></li>
<li>Result is a least-square approximation to the original co-occurrence matrix \(X\)
<img src="./img/svd-co-occur.png" alt="svd-co-occur.png" /></li>
<li>Single value is directly related to the new dimension that maximizes co-variance</li>
</ul>
</div>
</div>
<div id="outline-container-org66bcd71" class="outline-4">
<h4 id="org66bcd71"><span class="section-number-4">5.1.8.</span> Dense word embeddings</h4>
<div class="outline-text-4" id="text-5-1-8">

<div id="org61398a2" class="figure">
<p><img src="./img/dense.png" alt="dense.png" />
</p>
</div>
<ul class="org-ul">
<li>Each row of \(U\) is a \(k\) -dimensional representation of each word \(w\) in the corpus that best preserves variance</li>
<li>Generally, keep top \(k \in [50, 500]\) dimensions.</li>
<li>Produces dense vectors for word representations, while also considering the word contexts that carry meaning</li>
</ul>
</div>
</div>
<div id="outline-container-orgb5ea655" class="outline-4">
<h4 id="orgb5ea655"><span class="section-number-4">5.1.9.</span> Advantages of dense word embeddings</h4>
<div class="outline-text-4" id="text-5-1-9">
<ul class="org-ul">
<li>Denoising: low-order dimensions may represent unimportant information; higher-order dimensions keep only important information</li>
<li>Truncation may help models generalize better to unseen data</li>
<li>Having smaller number of dimensions may make it easier for classifiers to properly weigh the dimensions</li>
<li>Dense models may do better at capturing higher-order co-occurrence</li>
<li>Dense vectors work better in word similarity</li>
<li>Example of word-similarity method is cosine similarity between two word-embeddings \(w, v\):
\[
  \text{cosine} (\vec{v}, \vec{w}) =
  \frac{\vec{v}\cdot \vec{w}}{|\vec{v}| |\vec{w}|}
  = \frac{\sum^N_{i=1}v_i w_i}{\sqrt{\sum^N_{i=1} v_i^2} \sqrt{\sum^N_{i=1} w_i^2}}
  \]</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org6b17a69" class="outline-3">
<h3 id="org6b17a69"><span class="section-number-3">5.2.</span> GloVe</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Global Vectors.
</p>
</div>
<div id="outline-container-org24fbb56" class="outline-4">
<h4 id="org24fbb56"><span class="section-number-4">5.2.1.</span> Definitions</h4>
<div class="outline-text-4" id="text-5-2-1">
<dl class="org-dl">
<dt>Global</dt><dd>global statistics of corpus</dd>
<dt>Vectors</dt><dd>representation of words</dd>
</dl>
</div>
</div>
<div id="outline-container-orgb8d86da" class="outline-4">
<h4 id="orgb8d86da"><span class="section-number-4">5.2.2.</span> GloVe model</h4>
<div class="outline-text-4" id="text-5-2-2">
<ul class="org-ul">
<li>Glove uses statistics of word occurrences in a corpus as the primary source of information.</li>
<li>Combines 2 widely adopted approaches for training word vectors:
<ol class="org-ol">
<li>Global matrix factorization</li>
<li>Window-based methods</li>
</ol></li>
<li>Uses Co-occurrence matrix as a starting point</li>
</ul>
</div>
</div>
<div id="outline-container-org780c8cd" class="outline-4">
<h4 id="org780c8cd"><span class="section-number-4">5.2.3.</span> Extending the co-occurrence matrix</h4>
<div class="outline-text-4" id="text-5-2-3">
<dl class="org-dl">
<dt>Definition</dt><dd>For corpus of vocabulary \(V\) of size \(d\), the co-occurrence matrix is a symmetrical matrix of size \(d\times d\)</dd>
<dt>\(X_{ij}\)</dt><dd>number of times word \(j\) occurs in the context of word \(i\) after defining window size</dd>
<dt>\(X_i = \sum_k X_{ik}\)</dt><dd>summation over all the words which occur in the context of word \(i\)</dd>
<dt>\(P_{ij} = \frac{X_{ij}}{X_i}\)</dt><dd>the co-occurrence probability where \(_{ij}\) is the probability of word \(j\) occurring in the context of word \(i\)</dd>
</dl>
</div>
</div>
<div id="outline-container-orgaa31778" class="outline-4">
<h4 id="orgaa31778"><span class="section-number-4">5.2.4.</span> Example</h4>
<div class="outline-text-4" id="text-5-2-4">
<div class="BLOCKQUOTE" id="orgcc8a709">
<p>
It was the best of times, it was the worst of times.
(Context window=2)
</p>

</div>
<p>
i = "it", j = "was"
</p>
<ul class="org-ul">
<li>\(X_{i=0, j=1} = 2\)</li>
<li>\(X_{i=0} = 6\)</li>
<li>\(P{i=0, j=1} = 2/6 = 0.33\)</li>
</ul>
</div>
</div>
<div id="outline-container-org367d1d6" class="outline-4">
<h4 id="org367d1d6"><span class="section-number-4">5.2.5.</span> GloVe cost function</h4>
<div class="outline-text-4" id="text-5-2-5">
<ul class="org-ul">
<li>GloVe suggests finding the relationship between 2 words in terms of probability, rather than occurrence counts</li>
<li>GloVe looks to find vectors \(w_i\) and \(w_j\) such that
\[
  w_i^T w_j = \log(P_{ij}) = \log(\frac{X_{ij}}{X_i})
  \]</li>
<li>\(\log(X_i)\) is independent of word \(j\) and can be represented as a bias \(b_i\)</li>
<li>Adding a bias term to restore the symmetry for vector \(w_j\) we get:
\[
  w_i^T w_j + b_i + b_j = \log(X_{ij})
  \]</li>
<li><p>
A weighted least squares is used as a cost function for the GloVe model:
\[
  J = \sum_{ij} f(X_{ij})(w_i^T w_j + b_i + b_j - log(X_{ij}))^2
  \]
with:
</p>

\begin{equation}
f(x) =
\begin{cases}
(\frac{x}{x_{\text{max}}})^4 & \text{ if }x < x_{\text{max}} \\
1 & \text{otherwise}
\end{cases}
\end{equation}
<ul class="org-ul">
<li>In original paper, \(\alpha = \frac{3}{4}\) gave the best performance</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgb733128" class="outline-4">
<h4 id="orgb733128"><span class="section-number-4">5.2.6.</span> GloVe word vectors</h4>
<div class="outline-text-4" id="text-5-2-6">
<ul class="org-ul">
<li>Trained in batches of the training sample with optimizer to <b><b>minimize</b></b> the cost function and hence generate word and context vectors for each word</li>
<li>Each word in the corpus is represented bya dense vector of fixed size length</li>
<li>Word vectors obtained by GloVe showcase the meaning that was captured in these vector representations through similarity and linear structure</li>
<li>Using Euclidean distance or cosine similarity between word vectors represents <b><b>linguistic</b></b> or <b><b>semantic</b></b> similarity of the corresponding words.</li>
<li>E.g. "summer" is most similar to "winter", "spring", "autumn"</li>
</ul>
</div>
</div>
<div id="outline-container-org331ff68" class="outline-4">
<h4 id="org331ff68"><span class="section-number-4">5.2.7.</span> GloVe conserves linear relationships</h4>
<div class="outline-text-4" id="text-5-2-7">
<ul class="org-ul">
<li>Word vectors by GloVe conserve linear substructures</li>
<li>Vector differences capture as much as possible the meaning specified by two words</li>
<li>E.g.: the underlying concept that differentiates man and woman, i.e. gender, may be equivalently specified by other word pairs such as king and queen:
\[
  w_{\text{man}} - w_{\text{woman}} = w_{\text{king}} - w_{\text{queen}}
  \]</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb9ba954" class="outline-2">
<h2 id="orgb9ba954"><span class="section-number-2">6.</span> Week 8: Neural Networks and Word2Vec</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org69f1152" class="outline-3">
<h3 id="org69f1152"><span class="section-number-3">6.1.</span> Neural Networks</h3>
<div class="outline-text-3" id="text-6-1">
<p>
M6T1
</p>
</div>
<div id="outline-container-org01e52e1" class="outline-4">
<h4 id="org01e52e1"><span class="section-number-4">6.1.1.</span> Inspiration from biological neurons</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
Neurons: core components of the brain and nervous system.
Consists of:
</p>
<dl class="org-dl">
<dt>Dendrites</dt><dd>collect information from other neurons</dd>
<dt>Axon</dt><dd>generates outgoing spikes</dd>
</dl>
</div>
</div>
<div id="outline-container-org70b34d3" class="outline-4">
<h4 id="org70b34d3"><span class="section-number-4">6.1.2.</span> Logistic regression block review</h4>
<div class="outline-text-4" id="text-6-1-2">

<div id="org1b22515" class="figure">
<p><img src="./img/neuron-block.png" alt="neuron-block.png" />
</p>
</div>
<ul class="org-ul">
<li><b><b>Summation</b></b> part is a linear combination of features or dimensions - i.e. unique words in the document term matrix
<ul class="org-ul">
<li>Receives a data point as an input, which can be multi-dimensional</li>
<li>Linearly combines them using model parameters, shown as &theta; .</li>
<li>Linear combination of features, the output of the output of summation function, captures the linear relationship between input and output</li>
<li>Linear function may not be sufficient to capture the non-linear and complex relationship between input data points and their output.</li>
</ul></li>
<li>Hence, <b><b>activation</b></b> function is needed, which is fed by output of summation term.
<ul class="org-ul">
<li>Typically chosen to be a non-linear function, which helps the network understand and learn the complex relationship between input and output.</li>
<li>Well-known activation functions:
<dl class="org-dl">
<dt>Linear unit</dt><dd>does not change the output of the summation function. \(z\)</dd>
<dt>Threshold/Sign</dt><dd>used for hard classification algorithm. Positive or negative output for binary classification. Decision line is zero. \(\text{sgn}(z)\)</dd>
<dt>Sigmoid</dt><dd>used to scale output between \([0,1]\). Commonly used for classification problems. If used with 1 learning block, it's a logistic regression algorithm with soft classification. \(\frac{1}{1+\exp(-z)}\)</dd>
<dt>ReLu</dt><dd>Rectified linear unit. Commonly used in deep learning methods because of friendly optimization, back propagation and fast training of predictive model. \(\max(0,z)\)</dd>
<dt>Tangent hyperbolic (Tanh) unit</dt><dd>Scales a real value from -1 to +1. Captures negative values (vs. sigmoid unit), which just scales between \([0,1]\). \(\tanh(z)\)</dd>
</dl></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgeb92abb" class="outline-4">
<h4 id="orgeb92abb"><span class="section-number-4">6.1.3.</span> Connecting blocks to create neural networks</h4>
<div class="outline-text-4" id="text-6-1-3">
<p>
Recap:
</p>
<ul class="org-ul">
<li>a block received a data point or document having features, and linearly combines them in a summation function, that is then fed to activation function \(h(x)\).</li>
<li>New neuron or feature would help network and original features learn more complex relationship between inputs and outputs.</li>
<li>Artificial neural network can solve both regression and classification problems.</li>
<li>Fully connected network: each neuron needs to be connected to all the learning blocks.
<img src="./img/fc-neurons.png" alt="fc-neurons.png" />
<dl class="org-dl">
<dt>1</dt><dd>Bias value</dd>
<dt>\(x_i\)</dt><dd>Feature</dd>
<dt>\(\theta\)</dt><dd>Weights or parameters</dd>
<dt>\(\mu_{21}\)</dt><dd>summation output for layer 2, depth 1</dd>
</dl></li>

<li><span style='background-color: #FFFF00;'>last activation function</span> defines what model / problem we're trying to solve (regression or classification)</li>
<li>Layers not connected to the last learning block are <span style='background-color: #FFFF00;'>hidden layers</span></li>
<li>ANN can have many hidden layers, e.g. \(\theta_0\) till \(\theta_6\)</li>
<li>Changing the "first neuron" (last neuron) to sigmoid changes this to solve a <b><b>classification</b></b> problem</li>
</ul>
</div>
</div>
<div id="outline-container-org3b8549b" class="outline-4">
<h4 id="org3b8549b"><span class="section-number-4">6.1.4.</span> Increasing the depth of each layer</h4>
<div class="outline-text-4" id="text-6-1-4">
<p>
i.e. same number of layers, but more neurons
</p>
<ul class="org-ul">
<li>Can be doen by increasing the num,ber of learning blocks</li>
<li>This generates more O's, increasing the number of parameters</li>
</ul>
</div>
</div>
<div id="outline-container-org5fbcc3c" class="outline-4">
<h4 id="org5fbcc3c"><span class="section-number-4">6.1.5.</span> Increasing layers</h4>
<div class="outline-text-4" id="text-6-1-5">
<ul class="org-ul">
<li>Add more hidden layers</li>
<li>There can be as many hidden layers as needed</li>
<li>These are hyperparameters
<ul class="org-ul">
<li>Number of neurons</li>
<li>Number of hidden layers</li>
</ul></li>
<li>These hyperparameters need to be tuned for the complexity between inputs and outputs</li>
<li>Need to <span style='background-color: #FFFF00;'>prevent overfitting</span> especially if there's insufficient training or testing data</li>
</ul>
</div>
</div>
<div id="outline-container-orgb09e0c9" class="outline-4">
<h4 id="orgb09e0c9"><span class="section-number-4">6.1.6.</span> Forward pass</h4>
<div class="outline-text-4" id="text-6-1-6">
<p>
\[
u_{11} = \sum^d_{i=0} x_i \theta_i = \theta_0 + \theta_1 x_1 + ... + \theta_d x_d \\
O_{11} = \frac{1}{1+e^{-u_{11}}}
\]
</p>
<ul class="org-ul">
<li>In the forward pass, calculate all \(u_{ij}\) and \(o_{ij}\) values from <span style='background-color: #FFFF00;'>left to the right</span> of the network</li>
</ul>
</div>
</div>
<div id="outline-container-org0e5c7f9" class="outline-4">
<h4 id="org0e5c7f9"><span class="section-number-4">6.1.7.</span> Backpropagation</h4>
<div class="outline-text-4" id="text-6-1-7">
<ul class="org-ul">
<li>Update all \(\theta_i\) parameters from the right to the left of the network</li>
<li>Optimization can be done using iterative techniques such as gradient descent</li>
<li>Updating parameters depends on the types of loss functions:
<ul class="org-ul">
<li>Regression: RMSE</li>
<li>Classification: Cross-entropy</li>
</ul></li>
<li>Minimize the loss function by taking partial derivatives w.r.t. the model parameters</li>
<li>Last parameters are updated first, and use chaining rule to update the other parameters</li>
<li>Types of approaches
<dl class="org-dl">
<dt>Stochastic gradient descent or iteration</dt><dd>1 document at a time. Process one document at a time, need 1000 iterations to go through all data points. Each time going through all documents = 1 epoch. <span style='background-color: #FFFF00;'>Memory friendly</span> but computationally slow as we are updating parameters for each document one at a time.</dd>
<dt>Batch gradient descent</dt><dd>Pass a sub-portion of documents each time. E.g. if 50 documents / iteration, will reduce the number of iterations from 1000 to 20. Also possible to pass <b><b>all</b></b> data points at once, but usually can't fit in memory.</dd>
</dl></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge3d37f9" class="outline-3">
<h3 id="orge3d37f9"><span class="section-number-3">6.2.</span> Word2Vec, CBOW and Skipgram</h3>
<div class="outline-text-3" id="text-6-2">
<p>
M6L2
</p>
</div>
<div id="outline-container-org06d9c5f" class="outline-4">
<h4 id="org06d9c5f"><span class="section-number-4">6.2.1.</span> Review of One-Hot Encoding</h4>
<div class="outline-text-4" id="text-6-2-1">
<ul class="org-ul">
<li>Simplest word embedding.</li>
<li>Example 1 document: "Apple and orange are fruit". Vectors:
<dl class="org-dl">
<dt>Apple</dt><dd><code>[1, 0, 0, 0]</code></dd>
<dt>Orange</dt><dd><code>[0, 1, 0, 0]</code></dd>
<dt>Are</dt><dd><code>[0, 0, 1, 0]</code></dd>
<dt>Fruit</dt><dd><code>[0, 0, 0, 1]</code></dd>
</dl></li>
<li>Common words are removed first. They don't
provide distinguishing features for the words in the corpus.</li>
</ul>
</div>
</div>
<div id="outline-container-org390d75d" class="outline-4">
<h4 id="org390d75d"><span class="section-number-4">6.2.2.</span> Issues with One-Hot Embedding</h4>
<div class="outline-text-4" id="text-6-2-2">
<ul class="org-ul">
<li>The size of each word vector = vocabulary size in the corpus. Creates a huge vector if we have millions of words in the vocabulary.</li>
<li>Very long OHE vector wastes storage and computation</li>
<li>Curse of dimensionality can emerge for very large vectors</li>
<li>With a new corpus, the size of each word vector will be different and the model previously trained will be useless (can't transfer learning).</li>
</ul>
</div>
</div>
<div id="outline-container-org77c16f5" class="outline-4">
<h4 id="org77c16f5"><span class="section-number-4">6.2.3.</span> Contextual meaning of the words</h4>
<div class="outline-text-4" id="text-6-2-3">
<ul class="org-ul">
<li>Word2Vec and GLoVE are context-independent.
<ul class="org-ul">
<li>They output just one vector embedding for each word, combining all different senses of the word into 1 vector.</li>
</ul></li>
<li>E.g. for the example above, do "apple" and "fruit" share some common features since they're all fruit?
<ul class="org-ul">
<li>No, because OHE is just 0 and 1 embedding and does not consider the contextual meaning of words.
<ul class="org-ul">
<li><span style='background-color: #FFFF00;'>There is no correlation</span> between words that have similar meanings or usage.</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgdd4055e" class="outline-4">
<h4 id="orgdd4055e"><span class="section-number-4">6.2.4.</span> What do we want to achieve from word embeddings?</h4>
<div class="outline-text-4" id="text-6-2-4">
<ul class="org-ul">
<li>Can we come up with a word embedding that can capture a numerical similarity value? e.g.
<ul class="org-ul">
<li>Similarity value of (apple, orange) == similarity value of (orange, apple)</li>
<li>Similarity value of (apple, orange) &gt; similarity value of (apple, are)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org1b779ff" class="outline-4">
<h4 id="org1b779ff"><span class="section-number-4">6.2.5.</span> Algorithm 1:: Continuous Bag of Words (CBOW)</h4>
<div class="outline-text-4" id="text-6-2-5">
<ul class="org-ul">
<li>Use neural networks to learn the underlying representation of words</li>
<li><span style='background-color: #FFFF00;'>Caveat:</span> neural network model is a supervised algorithm. Needs labels. Must find a way to synthesize the labels from the corpus.</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org141133c"></a>Neighboring words for CBOW (label creation)<br />
<div class="outline-text-5" id="text-6-2-5-1">
<ul class="org-ul">
<li>i.e., Given the neighbors of a word, can we predict the center word?</li>
<li>Given the context or neighbours of a word, can I predict the blank by a window size?</li>
<li>Simplicity: keep window size of 1, and remove the common words.</li>
<li>Here, we want to find \(P(\text{orange}|\text{context})\), and need to maximize this probability.</li>
</ul>
</div>
</li>
<li><a id="org9671acb"></a>Embedding every single word in the corpus using its context<br />
<div class="outline-text-5" id="text-6-2-5-2">
<ul class="org-ul">
<li>Find the embedding representation of the word "orange".</li>
<li>First, all words in the vocabulary need to be encoded using OHE. Each word will have \(d\) dimensions (i.e., the size of the vocabulary).</li>
</ul>
</div>
</li>
<li><a id="org4b8a131"></a>Using a window size of 1<br />
<div class="outline-text-5" id="text-6-2-5-3">
<p>
[Apple, <span class="underline">_</span>, Are]
<img src="./img/window-size-1.png" alt="window-size-1.png" />
</p>
<ul class="org-ul">
<li>Uses a single hidden layer, which allows the embedding of a word.</li>
<li>Input vectors have the size of context,</li>
<li><span style='background-color: #FFFF00;'>In CHOW</span> the dimensions of the hidden layer and the output layer are always the same.</li>
<li>First weight \(d \times E\):
<dl class="org-dl">
<dt>d</dt><dd>dimension of one-hot encoded word</dd>
<dt>E</dt><dd>embedding size</dd>
</dl></li>
<li>What's the desirable size to vectorize each word of the corpus?</li>
<li>Size of \(E\) is also a hyperparameter. It's much smaller than \(d\).</li>
<li>Use weight matrix to embed word after it's trained by neural network.
<ul class="org-ul">
<li>Multiply word by word matrix W, results gives us the embedded word.</li>
</ul></li>
<li>Hidden layer will be calculated from average element wise-multiplication of each input vector for weights parameter \(w\).</li>
<li>Need to maximize a lot of likelihood by optimizing the parameters via backpropagation</li>
<li>Typically minimize negative log-likelihood instead of maximizing the original likelihood</li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-org32b71a6" class="outline-4">
<h4 id="org32b71a6"><span class="section-number-4">6.2.6.</span> Algorithm 2: Skip-Gram model</h4>
<div class="outline-text-4" id="text-6-2-6">
<ul class="org-ul">
<li>Given a center word, what could be the context (neighbours) of the center word?</li>
<li>Opposite of CBOW.</li>
<li>Example: <code>orange ___ fruit</code></li>
<li>Can I predict the blanks by a window size?
<ul class="org-ul">
<li>Window size is the hyperparameter</li>
</ul></li>
<li>To find and <span style='background-color: #FFFF00;'>maximize</span>: \(P(\text{context | orange})\).</li>
<li>Skipgram
<ul class="org-ul">
<li>Input layer: center word, i.e. "orange"</li>
<li>Output layer: the probability vector that is the prediction of all context words for each output context word.</li>
</ul></li>
<li>Calculate softmax probability</li>
<li>Next, in loss function, <span style='background-color: #FFFF00;'>minimize</span> the negative log likelihood over all softmax context words.</li>
<li>Use a <span style='background-color: #FFFF00;'>cross-entropy loss</span> as we treat this problem as a <b><b>classification</b></b> problem.</li>
</ul>
</div>
</div>
<div id="outline-container-org415a0fe" class="outline-4">
<h4 id="org415a0fe"><span class="section-number-4">6.2.7.</span> Main differences between CBOW and Skip-gram</h4>
<div class="outline-text-4" id="text-6-2-7">
<ul class="org-ul">
<li>CBOW learns better syntactic relationships between words; Skipgram captures better semantic relationships.
<ul class="org-ul">
<li>CBOW would provide cats and cants as similar, while skipgram will provide cats and dogs as similar.</li>
<li>CNOW is trained to predict (i.e., maximize the probaility) of a single word from a fixed window size of context words, while Skip-gram does the opposite and strives to predict several context words from a single input word.</li>
<li><span style='background-color: #FFFF00;'>CBOW is faster to train</span> vs. Skip-gram.</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: W</p>
<p class="date">Created: 2024-03-07 Thu 20:53</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
