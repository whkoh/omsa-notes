<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-02-25 Sun 21:57 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CSE 8803: Applied Natural Language Processing</title>
<meta name="author" content="W" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="../src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="../src/readtheorg_theme/css/readtheorg.css"/>
<script type="text/javascript" src="../src/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="../src/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="../src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">CSE 8803: Applied Natural Language Processing</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgb373f89">1. Week 1: Text data preprocessing + Course Intro</a>
<ul>
<li><a href="#orgd8d68e2">1.1. Why ANLP?</a></li>
<li><a href="#orga8cfddb">1.2. Lots of text and written information</a></li>
<li><a href="#orge014ad1">1.3. Example applications of NLP</a></li>
<li><a href="#orgf7d73fa">1.4. Challenges of NLP</a></li>
<li><a href="#org415c500">1.5. Class overview</a></li>
<li><a href="#org7e12583">1.6. Deliverables</a>
<ul>
<li><a href="#org2040024">1.6.1. Homework</a></li>
<li><a href="#org57f8ca0">1.6.2. Quizzes (10)</a></li>
</ul>
</li>
<li><a href="#org057c275">1.7. Course goals</a></li>
<li><a href="#org08319d7">1.8. Text Preprocessing Techniques</a>
<ul>
<li><a href="#org657f09c">1.8.1. Terminology</a></li>
<li><a href="#orga0f6095">1.8.2. Preprocessing text data</a></li>
<li><a href="#orgda4459e">1.8.3. Noise removal</a></li>
<li><a href="#org9bf5c4d">1.8.4. Tokenization</a></li>
<li><a href="#org457c57a">1.8.5. Text normalization</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgde10d41">2. Week 2: (Discrete) Text Representations</a>
<ul>
<li><a href="#org2389441">2.1. Why?</a></li>
<li><a href="#org121fb0e">2.2. Representing Words</a></li>
<li><a href="#orge05928d">2.3. Representing sentences/documents</a></li>
<li><a href="#orgff6d183">2.4. One Hot Encoding</a>
<ul>
<li><a href="#org086e9d0">2.4.1. Definitions</a></li>
<li><a href="#org1940aba">2.4.2. Advantages and disadvantages</a></li>
</ul>
</li>
<li><a href="#org58247cc">2.5. Bag of Words (Frequency Counting)</a>
<ul>
<li><a href="#org0d7f703">2.5.1. Advantages and disadvantages</a></li>
</ul>
</li>
<li><a href="#orga4cce0c">2.6. TF-IDF (Term Frequency-Inverse Document Frequency)</a>
<ul>
<li><a href="#orgade8a86">2.6.1. Why needed?</a></li>
<li><a href="#org19a48c0">2.6.2. What is TF-IDF and when to use TF-IDF</a></li>
<li><a href="#orgcfb6fc7">2.6.3. Advantages and disadvantages</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org33ed677">3. Week 3: Linear Text Classification</a>
<ul>
<li><a href="#org9169095">3.1. Classification introduction</a>
<ul>
<li><a href="#org6596988">3.1.1. Supervised learning: definitions</a></li>
<li><a href="#org5a6c7c4">3.1.2. Categories of supervised learning</a></li>
<li><a href="#org16a4380">3.1.3. Regression</a></li>
<li><a href="#org707eb63">3.1.4. Classification</a></li>
</ul>
</li>
<li><a href="#org4a4f8e7">3.2. Naive Bayes</a>
<ul>
<li><a href="#org4a525a7">3.2.1. Method / concepts</a></li>
<li><a href="#org13c1f18">3.2.2. Bayes decision rule</a></li>
<li><a href="#orga072638">3.2.3. Generative vs discriminative models</a></li>
<li><a href="#orgef8a76d">3.2.4. Details of Naive Bayes</a></li>
<li><a href="#org7fe9226">3.2.5. Naive Conditional Independence Assumption</a></li>
<li><a href="#org3abd8c8">3.2.6. Advantages and disadvantages</a></li>
</ul>
</li>
<li><a href="#org4972f92">3.3. Classification Model Evaluation</a>
<ul>
<li><a href="#orge4bed09">3.3.1. Common metrics</a></li>
<li><a href="#org6185a76">3.3.2. Confusion matrix</a></li>
<li><a href="#orgde0bb6d">3.3.3. Accuracy</a></li>
<li><a href="#orgc898b48">3.3.4. RoC-AUC curve</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga0d8bec">4. Week 5: Log Regression, SVM and Perceptron (Module 4)</a>
<ul>
<li><a href="#orga469be7">4.1. Logistic Regression</a>
<ul>
<li><a href="#org7eaffc5">4.1.1. Generative vs Discriminative Models (again)</a></li>
<li><a href="#orgb9e5bf7">4.1.2. Bayes equation again</a></li>
<li><a href="#orgb9c148e">4.1.3. Logistic Function for posterior probability</a></li>
<li><a href="#org4c38be5">4.1.4. Sigmoid is interpreted as probability</a></li>
<li><a href="#orgdece091">4.1.5. Logistic regression model</a></li>
<li><a href="#org0de8fb1">4.1.6. The gradient of \(l(\theta)\)</a></li>
<li><a href="#orgfb00f89">4.1.7. Gradient descent</a></li>
<li><a href="#orga6ac48b">4.1.8. Gradient ascent (concave) / descent (convex) algorithm</a></li>
<li><a href="#org06d39a2">4.1.9. Advantages and disadvantages of logistic regression</a></li>
</ul>
</li>
<li><a href="#orgb4ef167">4.2. Support vector machine</a>
<ul>
<li><a href="#org6925b0d">4.2.1. Linear separation</a></li>
<li><a href="#org1d8aaf9">4.2.2. Finding &theta; that maximizes margin</a></li>
<li><a href="#org8755701">4.2.3. Length of margin</a></li>
<li><a href="#orgf7bbe70">4.2.4. Maximizing margin</a></li>
<li><a href="#org7ebe2d9">4.2.5. Geometric representation</a></li>
<li><a href="#org5844b4f">4.2.6. Lagrange formulation (not in detail)</a></li>
<li><a href="#org797ecc2">4.2.7. Usage</a></li>
<li><a href="#org7ba2ef4">4.2.8. From \(x\) to \(z\) space</a></li>
<li><a href="#org0bd0b3c">4.2.9. Support vector machine</a></li>
</ul>
</li>
<li><a href="#orgb061d46">4.3. Perceptron</a>
<ul>
<li><a href="#org0e574b9">4.3.1. Linearly separable</a></li>
<li><a href="#orgd2cab88">4.3.2. Linear classifier</a></li>
<li><a href="#org30f33a8">4.3.3. The Perceptron Classifier</a></li>
<li><a href="#orgaa845de">4.3.4. Perceptron activation</a></li>
<li><a href="#orgcf3bd3a">4.3.5. Advantages and disadvantages of Perceptron</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org5998cb0">5. Week 6: Embeddings/Dimensionality reduction</a>
<ul>
<li><a href="#org4129b82">5.1. Motivating example</a></li>
<li><a href="#org3f1f91f">5.2. Bag of words representation</a></li>
<li><a href="#org89944a2">5.3. What is dimensionality reduction?</a></li>
<li><a href="#org956d61a">5.4. Intuition (of PCA)</a></li>
<li><a href="#org83b0e62">5.5. Singular value decomposition</a></li>
<li><a href="#org95fd720">5.6. Co-occurrence matrices</a></li>
<li><a href="#orged691ef">5.7. SVD on co-occurrence matrices</a></li>
<li><a href="#org0a9926b">5.8. Dense word embeddings</a></li>
<li><a href="#org0f569f8">5.9. Advantages of dense word embeddings</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgb373f89" class="outline-2">
<h2 id="orgb373f89"><span class="section-number-2">1.</span> Week 1: Text data preprocessing + Course Intro</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgd8d68e2" class="outline-3">
<h3 id="orgd8d68e2"><span class="section-number-3">1.1.</span> Why ANLP?</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Text and docs are everywhere</li>
<li>Hundreds of languages in the world</li>
<li>Primary information artifacts</li>
<li>Large volumes of textual data</li>
<li>Big and small companies looking for this skill</li>
</ul>
</div>
</div>
<div id="outline-container-orga8cfddb" class="outline-3">
<h3 id="orga8cfddb"><span class="section-number-3">1.2.</span> Lots of text and written information</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>Internet</li>
<li>Webpages, Facebook, Wikipedia, etc.</li>
<li>Digital libraries: Google Books, ACM, IEEE</li>
<li>Lyrics, subtitles, etc.</li>
<li>Police case reports</li>
<li>Legislation</li>
<li>Reviews</li>
<li>Medical reports</li>
<li>Job descriptions</li>
</ul>
</div>
</div>
<div id="outline-container-orge014ad1" class="outline-3">
<h3 id="orge014ad1"><span class="section-number-3">1.3.</span> Example applications of NLP</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>Establish authenticity, detect plagiarism</li>
<li>Classification of genres</li>
<li>Classification of tone; sentiment analysis</li>
<li>Syntax analysis in code</li>
<li>Machine translation</li>
</ul>
</div>
</div>
<div id="outline-container-orgf7d73fa" class="outline-3">
<h3 id="orgf7d73fa"><span class="section-number-3">1.4.</span> Challenges of NLP</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>Interdisciplinary field</li>
<li>Ambiguity at many levels of language:
<ol class="org-ol">
<li>Lexical (Word level)</li>
<li>Syntactic: different ways of parsing</li>
<li>Partial information: e.g., how to interpret pronouns</li>
<li>Contextual information: context of sentence may affect meaning of sentence</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org415c500" class="outline-3">
<h3 id="org415c500"><span class="section-number-3">1.5.</span> Class overview</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>Preprocessing:
<ul class="org-ul">
<li>Clean text and documents</li>
<li>Tokenization</li>
<li>Reducing inflectional forms of a word:
<ul class="org-ul">
<li>Stemming</li>
<li>Lemmatization</li>
</ul></li>
<li>Normalization</li>
</ul></li>
<li>Text representation
<ul class="org-ul">
<li>One hot encoding</li>
<li>Bag of words (Frequency counting)</li>
<li>Term frequency-Inverse document frequency (TF-IDF)</li>
<li>Embeddings</li>
</ul></li>
<li>Overview of classification methods
<ul class="org-ul">
<li>Naive Bayes</li>
<li>Logistic regression</li>
<li>SVM</li>
<li>Perceptron</li>
<li>Nerual Network</li>
</ul></li>
<li>Overview of Deep Learning
<ul class="org-ul">
<li>Convolutional neural network</li>
<li>Recurrent neural network</li>
<li>Long short-term memory</li>
</ul></li>
<li>Overview of topic modelling
<ul class="org-ul">
<li>Principal component analysis</li>
<li>Singular value decomposition</li>
<li>Latent Dirichlet Allocation</li>
</ul></li>
<li>Overview of Transformer methods
<ul class="org-ul">
<li>Bidirectional Encoder Representations from Transformers</li>
<li>Generative Pre-trained Transformers (GPT)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7e12583" class="outline-3">
<h3 id="org7e12583"><span class="section-number-3">1.6.</span> Deliverables</h3>
<div class="outline-text-3" id="text-1-6">
</div>
<div id="outline-container-org2040024" class="outline-4">
<h4 id="org2040024"><span class="section-number-4">1.6.1.</span> Homework</h4>
<div class="outline-text-4" id="text-1-6-1">
<ul class="org-ul">
<li>HW1: Text preprocessing and classification intro</li>
<li>HW2: Classification methods, dimensionality reduction, SVD</li>
<li>HW3: Deep learning</li>
<li>HW4: Transformers and unsupervised methods</li>
</ul>
</div>
</div>
<div id="outline-container-org57f8ca0" class="outline-4">
<h4 id="org57f8ca0"><span class="section-number-4">1.6.2.</span> Quizzes (10)</h4>
<div class="outline-text-4" id="text-1-6-2">
<ul class="org-ul">
<li>Measure understanding of topic</li>
<li>Mostly conceptual questions</li>
<li>MCQ</li>
<li>Limited time to do the test</li>
<li>Mandatory</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org057c275" class="outline-3">
<h3 id="org057c275"><span class="section-number-3">1.7.</span> Course goals</h3>
<div class="outline-text-3" id="text-1-7">
<ul class="org-ul">
<li>Demonstrate how to pre-process textual data</li>
<li>Differentiate text representation methods and techniques</li>
<li>Explain different NLP tasks</li>
<li>Develop and assess performance of different NLP models using a variety of techniques</li>
</ul>
</div>
</div>
<div id="outline-container-org08319d7" class="outline-3">
<h3 id="org08319d7"><span class="section-number-3">1.8.</span> Text Preprocessing Techniques</h3>
<div class="outline-text-3" id="text-1-8">
</div>
<div id="outline-container-org657f09c" class="outline-4">
<h4 id="org657f09c"><span class="section-number-4">1.8.1.</span> Terminology</h4>
<div class="outline-text-4" id="text-1-8-1">
<dl class="org-dl">
<dt>Corpus</dt><dd>collection of text, e.g. Yelp reviews, Wikipedia articles</dd>
<dt>Syntax</dt><dd>Grammatical structure of text</dd>
<dt>Syntactic parsing</dt><dd>process of analyzing natural language with grammatical rules</dd>
<dt>Semantics</dt><dd>meaning of text</dd>
<dt>Tokenization</dt><dd>splitting long pieces of text into smaller pieces (tokens). e.g.: <code>This is a simple sentence</code> -&gt; <code>["This", "is", "a", "simple", "sentence"]</code></dd>
<dt>Stop words</dt><dd>commonly used words, e.g. "the", "a", "an", "is", "are". Do not contribute to overall meaning</dd>
<dt>N-grams</dt><dd>consecutive sequence of words (commonly: 2-5) in a text. 1-gram (unigram), 2-gram (bigram), 3-gram (trigram). Example of bigrams: <code>"This is", "is a", "a simple", "simple sentence"</code></dd>
</dl>
</div>
</div>
<div id="outline-container-orga0f6095" class="outline-4">
<h4 id="orga0f6095"><span class="section-number-4">1.8.2.</span> Preprocessing text data</h4>
<div class="outline-text-4" id="text-1-8-2">
<ul class="org-ul">
<li>Text is unstructured, so preprocessing is the first step to prepare and clean text data to perform a NLP task</li>
<li>Useful libraries:
<ul class="org-ul">
<li>re: regular expressions</li>
<li>nltk: natural language toolkit</li>
</ul></li>
<li>Common steps:
<ul class="org-ul">
<li>Noise removal</li>
<li>Tokenization</li>
<li>Text normalization</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgda4459e" class="outline-4">
<h4 id="orgda4459e"><span class="section-number-4">1.8.3.</span> Noise removal</h4>
<div class="outline-text-4" id="text-1-8-3">
<p>
Removal of unwanted text formatting information, e.g.:
</p>
<ul class="org-ul">
<li>Punctuation</li>
<li>Accent marks</li>
<li>Special characters</li>
<li>Numeric digits (could be replaced with words)</li>
<li>Leading, ending and vertical whitespace</li>
<li>HTML formatting</li>
</ul>

<p>
Example: <code>This is a 'simple'' sentence !!! 1+ \n</code> -&gt; <code>This is a simple sentence</code>
</p>
</div>
</div>
<div id="outline-container-org9bf5c4d" class="outline-4">
<h4 id="org9bf5c4d"><span class="section-number-4">1.8.4.</span> Tokenization</h4>
<div class="outline-text-4" id="text-1-8-4">
<p>
Example:
<code>This is a simple sentence</code> -&gt;
<code>['This', 'is', 'a', 'simple', 'sentence', '.']</code>
</p>
</div>
</div>
<div id="outline-container-org457c57a" class="outline-4">
<h4 id="org457c57a"><span class="section-number-4">1.8.5.</span> Text normalization</h4>
<div class="outline-text-4" id="text-1-8-5">
<p>
Removing variations in the text to bring it to a standard form.
</p>
<ul class="org-ul">
<li>Case: Convert all letters to upper or lower case</li>
<li>Removing stop words, sparse terms, other special / particular words.</li>
</ul>

<p>
Example of text normalization:
<code>This is a Simple SenTence</code> -&gt;
<code>simple sentence</code>
</p>
<ul class="org-ul">
<li>Stemming: reduce words to word stem, base, or root form.
Example: <code>There are several tytpes of stemming algorithms</code> -&gt; <code>there are sever type fo stem algorithms.</code></li>
<li>Lemmatization: similar to stemming. Reduces inflectional forms to a common base form, <b><b>the lemma</b></b>. Does <b><b>not</b></b> simply chop off inflections. Uses <b><b>lexical knowledge</b></b> to get the correct base form of words.
Example: <code>There are several tytpes of stemming algorithms</code> -&gt; <code>There are several type of stemming algorithms.</code></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orgde10d41" class="outline-2">
<h2 id="orgde10d41"><span class="section-number-2">2.</span> Week 2: (Discrete) Text Representations</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org2389441" class="outline-3">
<h3 id="org2389441"><span class="section-number-3">2.1.</span> Why?</h3>
<div class="outline-text-3" id="text-2-1">
<dl class="org-dl">
<dt>NLP</dt><dd>design algorithms to allow computers to understand natural language, so as to perform some task</dd>
<dt>Required</dt><dd>convert text data to numerical data that can be used in model</dd>
</dl>
</div>
</div>
<div id="outline-container-org121fb0e" class="outline-3">
<h3 id="org121fb0e"><span class="section-number-3">2.2.</span> Representing Words</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>Can be represented by vectors of 0 &amp; 1 where 1 indicates the position of the word, e.g. lorem = <code>[1, 0]</code>, ipsum = <code>[0, 1]</code>, etc.</li>
</ul>
</div>
</div>
<div id="outline-container-orge05928d" class="outline-3">
<h3 id="orge05928d"><span class="section-number-3">2.3.</span> Representing sentences/documents</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>Vectors of vectors eg <code>[[1,0], [0,1]]</code></li>
</ul>
</div>
</div>
<div id="outline-container-orgff6d183" class="outline-3">
<h3 id="orgff6d183"><span class="section-number-3">2.4.</span> One Hot Encoding</h3>
<div class="outline-text-3" id="text-2-4">
</div>
<div id="outline-container-org086e9d0" class="outline-4">
<h4 id="org086e9d0"><span class="section-number-4">2.4.1.</span> Definitions</h4>
<div class="outline-text-4" id="text-2-4-1">
<dl class="org-dl">
<dt>corpus</dt><dd>all texts</dd>
<dt>vocabulary, <span class="underline">V</span></dt><dd>all unique words</dd>
<dt>vocabulary size, <span class="underline">d</span></dt><dd>number of unique words, "dimensions"</dd>
<dt>word, <span class="underline">w</span></dt><dd>represented by vector \(X\)</dd>
</dl>
<p>
\(X^w_i\) = 1 if idw(w) = 1, 0 otherwise
</p>
<dl class="org-dl">
<dt>document</dt><dd>represented by matrix sized \(n \times d\)</dd>
<dt><span class="underline">n</span></dt><dd>number of words in document</dd>
<dt><span class="underline">d</span></dt><dd>a single vector with multiple values of 1 where vocab. words are present</dd>
<dt>Document, <span class="underline">D</span></dt><dd>e.g. <span class="underline">this is a sentence</span></dd>
<dt>Vocabulary, <span class="underline">V</span></dt><dd>e.g. <code>[aardvark, ..., sentence, ..., zither]</code></dd>
<dt>OHE, \(X^D\)</dt><dd><code>[0, ..., 1, ...1]</code></dd>
</dl>
</div>
</div>
<div id="outline-container-org1940aba" class="outline-4">
<h4 id="org1940aba"><span class="section-number-4">2.4.2.</span> Advantages and disadvantages</h4>
<div class="outline-text-4" id="text-2-4-2">
<ul class="org-ul">
<li>Advantages: easy to implement</li>
<li>Disadvantages:
<ul class="org-ul">
<li>not scalable for large vocabulary</li>
<li>high dimensional sparse matrix results in expensive memory + computation</li>
<li><p>
each word represented individually, hence <b>no notion of similarity or meaning</b>. All vectors are orthogonal
</p>

<p>
\((w^{good})^T \cdot w^{great} = (w^{good})^T \cdot w^{bad} = 0\)
</p></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org58247cc" class="outline-3">
<h3 id="org58247cc"><span class="section-number-3">2.5.</span> Bag of Words (Frequency Counting)</h3>
<div class="outline-text-3" id="text-2-5">
<dl class="org-dl">
<dt>Summary</dt><dd>Represents each document as a bag of words. <b><b>Ignores</b></b> order of words.</dd>
<dt>Document</dt><dd>a column vector of \(X\) word counts</dd>
<dt>Representation</dt><dd>Fixed-length representation</dd>
<dt>Document, <span class="underline">D</span></dt><dd>e.g. <code>It was the best of times, it was the worst of times</code></dd>
<dt>Vocabulary, <span class="underline">V</span></dt><dd>e.g. <code>[aardvark, ..., zither]</code></dd>
<dt>Bag of words: <span class="underline">X</span></dt><dd>[2, &#x2026;, 1]</dd>
<dt>Size of <span class="underline">X</span></dt><dd>\(1 \times d\) (\(d\) = vocabulary size)</dd>
</dl>
<p>
Hence \(n\) documents can be represented by matrix of size \(n \times d\).
</p>
</div>
<div id="outline-container-org0d7f703" class="outline-4">
<h4 id="org0d7f703"><span class="section-number-4">2.5.1.</span> Advantages and disadvantages</h4>
<div class="outline-text-4" id="text-2-5-1">
<ul class="org-ul">
<li>Advantages: easy to implement</li>
<li>Disadvantages:
<ul class="org-ul">
<li>Not scalable for large vocabulary</li>
<li>high dimensional sparse matrix results in expensive memory + computation</li>
<li>Order of words is disregarded; <b><b>no meaning</b></b> from context</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga4cce0c" class="outline-3">
<h3 id="orga4cce0c"><span class="section-number-3">2.6.</span> TF-IDF (Term Frequency-Inverse Document Frequency)</h3>
<div class="outline-text-3" id="text-2-6">
</div>
<div id="outline-container-orgade8a86" class="outline-4">
<h4 id="orgade8a86"><span class="section-number-4">2.6.1.</span> Why needed?</h4>
<div class="outline-text-4" id="text-2-6-1">
<ul class="org-ul">
<li>BoW does not provide logical importance
<ul class="org-ul">
<li>i.e., each word is equally important</li>
</ul></li>
<li>TF-IDF assigns more logical importance to words in each document</li>
</ul>
</div>
</div>
<div id="outline-container-org19a48c0" class="outline-4">
<h4 id="org19a48c0"><span class="section-number-4">2.6.2.</span> What is TF-IDF and when to use TF-IDF</h4>
<div class="outline-text-4" id="text-2-6-2">
<dl class="org-dl">
<dt>Definition of TF-IDF</dt><dd>a word's <b><b>importance score</b></b> in a document among \(N\) documents</dd>
<dt><span class="underline">N</span></dt><dd>total number of documents</dd>
<dt>Word count</dt><dd>likely TF-IDF</dd>
<dt>Term frequency, <span class="underline">TF</span></dt><dd>the number of times a word appears in <b><b>a document</b></b>.
TF is high if word appears many times in document, e.g. <span class="underline">the</span>, <span class="underline">a</span>, etc.</dd>
<dt>Inverse document frequency, <span class="underline">IDF</span></dt><dd>\(\log(\frac{N}{\text{number of docs containing the term}})\).
If all (or most) documents contain that term, then IDF will be <b><b>very small</b></b></dd>
<dt>Word's importance score</dt><dd>\(TF \times IDF\).
Higher score = more "characteristic"</dd>
</dl>
</div>
</div>
<div id="outline-container-orgcfb6fc7" class="outline-4">
<h4 id="orgcfb6fc7"><span class="section-number-4">2.6.3.</span> Advantages and disadvantages</h4>
<div class="outline-text-4" id="text-2-6-3">
<ul class="org-ul">
<li>Advantages:
<ul class="org-ul">
<li>Easy to implement</li>
<li>Higher score = "more characteristic". Common words will have very small scores.</li>
<li>Good technique to search for documents, find similar documents, cluster documents</li>
</ul></li>
<li>Disadvantages
<ul class="org-ul">
<li>Does not consider position of words when creating matrix. Similar problem as with BoW.</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org33ed677" class="outline-2">
<h2 id="org33ed677"><span class="section-number-2">3.</span> Week 3: Linear Text Classification</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org9169095" class="outline-3">
<h3 id="org9169095"><span class="section-number-3">3.1.</span> Classification introduction</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Note: <b><b>classification</b></b>.
</p>
</div>
<div id="outline-container-org6596988" class="outline-4">
<h4 id="org6596988"><span class="section-number-4">3.1.1.</span> Supervised learning: definitions</h4>
<div class="outline-text-4" id="text-3-1-1">
<dl class="org-dl">
<dt>Word count matrix / document term matrix</dt><dd>dataset generated from documents</dd>
<dt>Rows of matrix</dt><dd>each row is 1 document</dd>
<dt>Columns of matrix</dt><dd>each column is 1 unique word</dd>
<dt>Unique words: synonyms</dt><dd>features, dimensions, attributes, variables, columns</dd>
<dt>Documents: synonyms</dt><dd>rows, data points, instances</dd>
<dt>Model weights</dt><dd>= model parameters, i.e. what the model learns</dd>
<dt>Function \(F\)</dt><dd>maps \(X\) to \(Y\)</dd>
<dt>Training data \((x_i, y_i)\)</dt><dd>within set of \({X \times Y}\)</dd>
<dt>Learning - find \(\hat{f}\)</dt><dd>\(\hat{f} \in F\) s.t. \(y_i \approx \hat{f} (x_i)\)</dd>
<dt>New data</dt><dd>\(x\)</dd>
<dt>Prediction \(y\)</dt><dd>\(= \hat{f} (x)\)</dd>
</dl>

<p>
Supervised learning thus takes <b><b>labelled</b></b> training data and <b><b>learns</b></b> or <b><b>derives</b></b> a function \(f(x): y = f(x)\).
</p>
</div>
</div>

<div id="outline-container-org5a6c7c4" class="outline-4">
<h4 id="org5a6c7c4"><span class="section-number-4">3.1.2.</span> Categories of supervised learning</h4>
<div class="outline-text-4" id="text-3-1-2">
<dl class="org-dl">
<dt>continuous \(y\)</dt><dd>regression i.e. curve fitting</dd>
<dt>discrete \(y\)</dt><dd>classification i.e. class estimation</dd>
</dl>
</div>
</div>

<div id="outline-container-org16a4380" class="outline-4">
<h4 id="org16a4380"><span class="section-number-4">3.1.3.</span> Regression</h4>
<div class="outline-text-4" id="text-3-1-3">
<ul class="org-ul">
<li>Errors represent how much predictions deviate from actual values.</li>
<li>Minimum error = 0, however beware of overfitting, where test errors will be high (trained model cannot generalize).</li>
<li>Example: apartment rent prediction, stock price prediction (difficult due to many predictors, known and unknown).</li>
</ul>
</div>
</div>

<div id="outline-container-org707eb63" class="outline-4">
<h4 id="org707eb63"><span class="section-number-4">3.1.4.</span> Classification</h4>
<div class="outline-text-4" id="text-3-1-4">
<ul class="org-ul">
<li>Linear classification can be used for spam detection, sentiment analysis, handwriting digit recognition (0.4% error here), etc.</li>
<li>Prepare, clean data, fit a classifier</li>
<li>Retraining is required due to new evolving context, new lingo, etc. Can be implemented into a learning system.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org4a4f8e7" class="outline-3">
<h3 id="org4a4f8e7"><span class="section-number-3">3.2.</span> Naive Bayes</h3>
<div class="outline-text-3" id="text-3-2">
</div>
<div id="outline-container-org4a525a7" class="outline-4">
<h4 id="org4a525a7"><span class="section-number-4">3.2.1.</span> Method / concepts</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
Bayes Decision Rule.
</p>
<dl class="org-dl">
<dt>\(x\)</dt><dd>encoded document, e.g. by BoW</dd>
<dt>\(y\)</dt><dd>label of document, i.e. whether document contains positive or negative message</dd>
<dt>Posterior</dt><dd>\(P(y|x)\)</dd>
<dt>Likelihood</dt><dd>\(P(x|y)\)</dd>
<dt>Prior</dt><dd>\(P(y)\)</dd>
<dt>Normalization constant</dt><dd>\(P(x)\)</dd>
</dl>

<p>
\[
P(y|x) = \frac{P(x|y)P(y)}{P(x)} = \frac{P(x,y)}{\sum_y P(x,y)}
\]
</p>
</div>
</div>
<div id="outline-container-org13c1f18" class="outline-4">
<h4 id="org13c1f18"><span class="section-number-4">3.2.2.</span> Bayes decision rule</h4>
<div class="outline-text-4" id="text-3-2-2">
<ul class="org-ul">
<li><span style='background-color: #FFFF00;'>important</span>: normalization constant is the same for +ve and -ve labels, hence no need to calculate when predicting sentiment</li>
</ul>
</div>
</div>
<div id="outline-container-orga072638" class="outline-4">
<h4 id="orga072638"><span class="section-number-4">3.2.3.</span> Generative vs discriminative models</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
Naive Bayes is a generative model
</p>
<ul class="org-ul">
<li>Generative model: able to generate synthetic data points
<ul class="org-ul">
<li><b><b>Need</b></b> to model prior and likelihood distributions.</li>
<li>In Naive Bayes, we normally replace likelihood with the conditional distribution.</li>
<li>Conditional distribution is the pdf/pmf to generate data points.
<ul class="org-ul">
<li>Determining this distribution might be difficult.</li>
</ul></li>
<li>Generative models e.g.: Naive Bayes, Hidden Markov Models</li>
</ul></li>
<li>Discriminative models:
<ul class="org-ul">
<li>Directly estimate posteriors</li>
<li>No need to model prior and likelihood distributions</li>
<li>e.g.: logistic regression, SVM, neural networks</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgef8a76d" class="outline-4">
<h4 id="orgef8a76d"><span class="section-number-4">3.2.4.</span> Details of Naive Bayes</h4>
<div class="outline-text-4" id="text-3-2-4">
<p>
Bayes decision rule:
\[
P(y|x) = \frac{P(x|y)P(y)}{P(x)}
\]
</p>
<ul class="org-ul">
<li><span style='background-color: #FFFF00;'>assumption</span>: all dimensions (unique words) are independent of each other, i.e. \(p(x|y = 1)\) fully factorized, hence: \(P(x|y=1) = \prod^d_{i=1} P(x_i|y = 1)\)
<ul class="org-ul">
<li>Thus, likelihood can be written in fully factorized way.</li>
<li>It becomes a big joint probability of all unique words (dimensions).</li>
<li>Conditional independence, hence likelihood can be written as multiplication of every dimension given the label.</li>
<li>i.e., the variables corresponding to each dimension are independent given the label.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7fe9226" class="outline-4">
<h4 id="org7fe9226"><span class="section-number-4">3.2.5.</span> Naive Conditional Independence Assumption</h4>
<div class="outline-text-4" id="text-3-2-5">
<p>
\[
P(y|x) = \frac{P(x|y)P(y)}{P(x)}
\]
</p>

<p>
For vocabulary \(V\), <code>[nice, give, us, this, iu, ssn, information, job, a]</code>
</p>

<p>
\(P(\text{document} | y = \text{positive})P(y=\text{positive})\)
</p>

<p>
= \(P(x=\text{nice}) ... P(x=a|y=\text{positive})\) \(\cdot P(y= \text{positive})\)
</p>

<p>
similarly for negatives:
</p>

<p>
\(P(\text{document} | y = \text{negative})P(y=\text{negative})\)
</p>

<p>
= \(P(x=\text{nice}) ... P(x=a|y=\text{negative})\) \(\cdot P(y= \text{negative })\)
</p>
</div>
<ol class="org-ol">
<li><a id="org92d849d"></a>Representing the likelihood<br />
<div class="outline-text-5" id="text-3-2-5-1">
<p>
Common distribution: <b><b>multinomial distribution</b></b>.
</p>

<p>
\[
P(x=\text{nice} | y = \text{positive})
\]
</p>

<p>
\[
= \frac{\text{count of word }\textbf{nice} \text{ in all positive label docs }}{\text{count all words with } \textbf{positive}  \text{  labels}}
\]
</p>

<p>
Then to calc priors:
</p>

<p>
\[
P(y = \text{positive}) = \frac{\text{count # +ve docs}}{\text{count # all docs}}
\]
</p>

<p>
Repeat above for negatives.
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-org3abd8c8" class="outline-4">
<h4 id="org3abd8c8"><span class="section-number-4">3.2.6.</span> Advantages and disadvantages</h4>
<div class="outline-text-4" id="text-3-2-6">
<ul class="org-ul">
<li>Advantages
<ul class="org-ul">
<li>Simple, easy to implement</li>
<li>No training required</li>
<li>Good results in general</li>
</ul></li>
<li>Disadvantages
<ul class="org-ul">
<li>Position of words do not matter (no semantic meaning) due to BoW approach</li>
<li>Requires / assumes conditional independence</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org4972f92" class="outline-3">
<h3 id="org4972f92"><span class="section-number-3">3.3.</span> Classification Model Evaluation</h3>
<div class="outline-text-3" id="text-3-3">
</div>
<div id="outline-container-orge4bed09" class="outline-4">
<h4 id="orge4bed09"><span class="section-number-4">3.3.1.</span> Common metrics</h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li>Classification: accuracy, precision, recall, cross-entropy, perplexity, and F1 score</li>
<li>Regression: MSE, MAE</li>
</ul>
</div>
</div>
<div id="outline-container-org6185a76" class="outline-4">
<h4 id="org6185a76"><span class="section-number-4">3.3.2.</span> Confusion matrix</h4>
<div class="outline-text-4" id="text-3-3-2">
<ul class="org-ul">
<li>e.g. for multi-label confusion matrix</li>
<li>rows are the actual classes (sport, news politics)</li>
<li>columns are the predicted classes</li>
<li>diagonal elements are number of accurate predictions</li>
<li>off-diagonals: inaccurate predictions</li>
<li>But difficult to parse, can consider using a heat map on the confusion matrix instead of raw #</li>
<li><span style='background-color: #FFFF00;'>meaning of positive and negative in a confusion matrix</span>: not related to sentiment. Only indicator of the label, e.g. sport = positive, news = negative.</li>
</ul>
</div>
</div>
<div id="outline-container-orgde0bb6d" class="outline-4">
<h4 id="orgde0bb6d"><span class="section-number-4">3.3.3.</span> Accuracy</h4>
<div class="outline-text-4" id="text-3-3-3">
<ul class="org-ul">
<li>Accuracy = (True Positive + True Negative) / Total observations, i.e. sum of diagonals / count observations.</li>
<li>May not be represent "goodness" since false positives and false negatives have identical treatment.</li>
<li>FP and FN may be important specifically for some fields e.g. medicine.</li>
<li>Another metric, false alarm (false positive, type I error) is easy to remember in security contexts.</li>
</ul>
</div>
</div>
<div id="outline-container-orgc898b48" class="outline-4">
<h4 id="orgc898b48"><span class="section-number-4">3.3.4.</span> RoC-AUC curve</h4>
<div class="outline-text-4" id="text-3-3-4">
<ul class="org-ul">
<li>ROC: Receiver Operating Characteristic</li>
<li>Changing thresholds: how to change, what should the new threshold be?</li>
<li>TP (y-axis) vs FP (x-axis)</li>
<li>AUC (area under the curve) represents the how performant the predictive model is. Max is 1.0.</li>
<li>But 0.9 may not be good either.
<ul class="org-ul">
<li>Are there some thresholds where TP = 0? Are these important in the context?</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orga0d8bec" class="outline-2">
<h2 id="orga0d8bec"><span class="section-number-2">4.</span> Week 5: Log Regression, SVM and Perceptron (Module 4)</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orga469be7" class="outline-3">
<h3 id="orga469be7"><span class="section-number-3">4.1.</span> Logistic Regression</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>Backbone of neural network model</li>
<li>Created on linear combination of features</li>
<li>Outputs a <b>probability</b>
<ul class="org-ul">
<li>Logistic regression is thus a <b>soft classification</b></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org7eaffc5" class="outline-4">
<h4 id="org7eaffc5"><span class="section-number-4">4.1.1.</span> Generative vs Discriminative Models (again)</h4>
<div class="outline-text-4" id="text-4-1-1">
<ul class="org-ul">
<li>Generative model: able to generate synthetic data points
<ul class="org-ul">
<li><b><b>Need</b></b> to model prior and likelihood distributions.</li>
<li>Conditional distribution is the pdf/pmf to generate data points.
<ul class="org-ul">
<li>Determining this distribution might be difficult.</li>
</ul></li>
<li>Generative models e.g.: Naive Bayes, Hidden Markov Models (HMM)</li>
</ul></li>
<li>Discriminative models:
<ul class="org-ul">
<li>Directly estimate posteriors</li>
<li>No need to model prior and likelihood distributions</li>
<li>e.g.: logistic regression, SVM, neural networks</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgb9e5bf7" class="outline-4">
<h4 id="orgb9e5bf7"><span class="section-number-4">4.1.2.</span> Bayes equation again</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
\[
P(y|x) = \frac{P(x|y)P(y)}{P(x)} = \frac{P(x,y)}{\sum_y P(x,y)}
\]
</p>
<dl class="org-dl">
<dt>Generative models</dt><dd>need to calculate likelihood and prior explicitly</dd>
<dt>Discriminative models</dt><dd>can we calculate posterior directly without using Bayes equation?</dd>
</dl>
</div>
</div>
<div id="outline-container-orgb9c148e" class="outline-4">
<h4 id="orgb9c148e"><span class="section-number-4">4.1.3.</span> Logistic Function for posterior probability</h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
i.e. the following function
</p>

<p>
\[
P(y|x) = g(s) = \frac{e^s}{1+e^s} = \frac{1}{1+e^{-s}}
\]
</p>

<ul class="org-ul">
<li>This function is known as the <b><b>sigmoid function</b></b>.</li>
<li>Easy to use this for optimization</li>
<li>Threshold: always 0.5?
<ul class="org-ul">
<li>Threshold can be investigated with ROC-AUC to determine best threshold</li>
</ul></li>
<li>Neural network with just 1 block is similar to logistic regression</li>
<li>Logistic regression: sigmoid is the activation function</li>
</ul>


<div id="org1988a83" class="figure">
<p><img src="./img/sigmoid.png" alt="sigmoid.png" />
</p>
</div>

<ul class="org-ul">
<li>Three linear models with different activation functions
<ul class="org-ul">
<li>Using a <b><b>sine</b></b> activation function: it will be transformed to perceptron, a hard classification</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org4c38be5" class="outline-4">
<h4 id="org4c38be5"><span class="section-number-4">4.1.4.</span> Sigmoid is interpreted as probability</h4>
<div class="outline-text-4" id="text-4-1-4">
<ul class="org-ul">
<li><p>
e.g., does a customer like a product based on feedback?
</p>
<ul class="org-ul">
<li>Input: \(x\) a BoW or TF-IDF of a document that contains customer's feedback</li>
<li>\(g(s)\) is the probability of whether a customer likes a product</li>
<li>Cannot have hard prediction or classification here</li>
</ul>
\begin{equation}
s = x\theta \text{ the risk score} \\
h_\theta (x) = p(y|x) =
\begin{cases}
g(s) & y=1 \\
1-(gs) & y=0 \text{ using posterior probability directly}
\end{cases}
\end{equation}</li>
<li>Sigmoid is the inverse of <b>logit</b> function (or the log-odds ratio)</li>
</ul>
</div>
</div>
<div id="outline-container-orgdece091" class="outline-4">
<h4 id="orgdece091"><span class="section-number-4">4.1.5.</span> Logistic regression model</h4>
<div class="outline-text-4" id="text-4-1-5">
<ul class="org-ul">
<li>Expanding equation and replacing \(g(s)\) with linear combination of features</li>
<li>Probabilistic model</li>
<li>Uses MLE to optimize linear combination of features</li>
<li>Use log-likelihood for better numerical stability</li>
<li><p>
To find &theta; parameters, for \(n\) data points:
</p>
\begin{equation}
P(y|x) =
\begin{cases}
\frac{1}{1+ \exp(-x\theta)} & y=1 \\
1-\frac{1}{1+\exp(-x\theta)} = \frac{\exp(-x\theta)}{1+\exp(-x\theta)} & y=0
\end{cases}
\end{equation}</li>
</ul>
</div>
</div>
<div id="outline-container-org0de8fb1" class="outline-4">
<h4 id="org0de8fb1"><span class="section-number-4">4.1.6.</span> The gradient of \(l(\theta)\)</h4>
<div class="outline-text-4" id="text-4-1-6">
<p>
\[
l(\theta) := \log \prod^n_{i=1} p(y_i, |x_i, \theta) \\
= \sum_i \theta^T x_i^T (y_i -1) - \log(1+\exp(-x_i \theta))
\]
<b><b>Gradient</b></b>:
\[
\frac{\partial l(\theta)}{\partial \theta} =
\sum_i x_i^T (y_i-1) + x_i^T \frac{\exp(-x_i \theta)}{1+\exp(-x_i \theta)}
\]
</p>
<ul class="org-ul">
<li>Even when set to 0, there is <b><b>no</b></b> closed-form solution.
<ul class="org-ul">
<li>Even though there is a global solution</li>
<li>Unlike linear regression where there is a closed-form solution</li>
<li>Hence, logistic regression is unconstrained, but</li>
<li>Can optimize using iterative approach such as gradient descent</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgfb00f89" class="outline-4">
<h4 id="orgfb00f89"><span class="section-number-4">4.1.7.</span> Gradient descent</h4>
<div class="outline-text-4" id="text-4-1-7">
<ul class="org-ul">
<li>One way to solve unconstrained optimization problem is gradient descent</li>
<li>Given initial guess, we iteratively refine the guess by taking the direction of the <span style='background-color: #FFFF00;'>negative gradient</span></li>
<li>Analogous to going down the hill by taking steepest direction at each step</li>
<li>Update rule
\[
  x_{k+1} = x_k - \eta_k \nabla f(x_k)
  \]
\(\eta_k\) is the <span style='background-color: #FFFF00;'>step size or learning rate</span></li>
<li>Step taken should be small enough</li>
</ul>
</div>
</div>
<div id="outline-container-orga6ac48b" class="outline-4">
<h4 id="orga6ac48b"><span class="section-number-4">4.1.8.</span> Gradient ascent (concave) / descent (convex) algorithm</h4>
<div class="outline-text-4" id="text-4-1-8">
<ul class="org-ul">
<li>Initialize parameter \(\theta_0\)</li>
<li>Do:
\[
  \theta_{t+1} \leftarrow \theta^t + \eta \sum_i x_i^T (y_i-1) + x_i^T \frac{\exp(-x_i \theta)}{1+\exp(-x_i \theta)}
  \]</li>
<li>while:
\[
  \parallel \theta^{t+1} - \theta^t \parallel > \epsilon
  \]</li>
<li>ascent: maximize function</li>
<li>descent: minimize</li>
<li>Thus:
<ul class="org-ul">
<li>Logical threshold = 0.5, i.e. predict 1 if \(g(s) \ge 0.5\)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org06d39a2" class="outline-4">
<h4 id="org06d39a2"><span class="section-number-4">4.1.9.</span> Advantages and disadvantages of logistic regression</h4>
<div class="outline-text-4" id="text-4-1-9">
<ul class="org-ul">
<li>Advantages:
<ul class="org-ul">
<li>Simple</li>
<li>No need to model prior or likelihood</li>
<li>Provides probability output</li>
<li>Works with datasets with few features</li>
</ul></li>
<li>Disadvantages:
<ul class="org-ul">
<li>Needs to have discriminative model assumption</li>
<li>Model needs to be optimized using numerical approach</li>
<li>Might not work with complicated dataset</li>
</ul></li>
</ul>
<p>
**
</p>
</div>
</div>
</div>
<div id="outline-container-orgb4ef167" class="outline-3">
<h3 id="orgb4ef167"><span class="section-number-3">4.2.</span> Support vector machine</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>SVM is a large margin classifier</li>
</ul>
</div>
<div id="outline-container-org6925b0d" class="outline-4">
<h4 id="org6925b0d"><span class="section-number-4">4.2.1.</span> Linear separation</h4>
<div class="outline-text-4" id="text-4-2-1">
<ul class="org-ul">
<li>Can have different separating lines, so which line is the best?
<ul class="org-ul">
<li>Why is having bigger margin better?</li>
<li>What &theta; maximizes margin?</li>
</ul></li>
</ul>

<div id="org34607ee" class="figure">
<p><img src="./img/lin-sep.png" alt="lin-sep.png" />
</p>
</div>
<ul class="org-ul">
<li>All cases, error is zero and they are linear, so they are all good for generalization.</li>
<li>SVM focuses on just one solution (compared to perceptron) and that's the maximum margin solution</li>
<li>SVM maximizes margin and provides decision line with maximized margin, which is the <span style='background-color: #FFFF00;'>most stable</span> under perturbations of inputs</li>
</ul>
</div>
</div>
<div id="outline-container-org1d8aaf9" class="outline-4">
<h4 id="org1d8aaf9"><span class="section-number-4">4.2.2.</span> Finding &theta; that maximizes margin</h4>
<div class="outline-text-4" id="text-4-2-2">
<ul class="org-ul">
<li>Objective function created by constructing linear combination of features.
<ul class="org-ul">
<li>Solution (decision boundary) of the line
\[
    x \theta = 0
    \]</li>
<li>Let \(x_i\) be the nearest data point to the line/plane</li>
<li>Decision boundary is thus \(x\theta + b = 0\)
<ul class="org-ul">
<li>Below decision line: &le; 0</li>
<li>Above decision line: &ge; 0</li>
</ul></li>
<li>Scaling up / down &theta; thus allows you to set the nearest point to \(1\).</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org8755701" class="outline-4">
<h4 id="org8755701"><span class="section-number-4">4.2.3.</span> Length of margin</h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
\[
\text{distance} = \frac{1}{\parallel \theta \parallel} |(x_i \theta - x \theta)|
= \frac{1}{\parallel \theta \parallel}|(x_i \theta + b - x\theta -b)|
\]
where:
</p>
<dl class="org-dl">
<dt>\(x_i \theta + b\)</dt><dd>my constraint \(\equiv |x_i \theta + b| = 1\)</dd>
<dt>\(-x\theta - b\)</dt><dd>a point on the decision line \(\equiv x\theta + b = 0\)</dd>
</dl>

<p>
Therefore total margin is: \(\frac{2}{\parallel \theta \parallel}\) (since there are 2 points on each side of the decision line)
</p>


<div id="orgadeca5f" class="figure">
<p><img src="./img/large-margin.png" alt="large-margin.png" />
</p>
</div>

<ul class="org-ul">
<li>&theta; is <span style='background-color: #FFFF00;'>orthogonal</span> to the decision line</li>
</ul>
</div>
</div>
<div id="outline-container-orgf7bbe70" class="outline-4">
<h4 id="orgf7bbe70"><span class="section-number-4">4.2.4.</span> Maximizing margin</h4>
<div class="outline-text-4" id="text-4-2-4">
<ul class="org-ul">
<li>Maximize \(\frac{2}{\parallel \theta \parallel}\) in the objective function</li>
<li>Subject to \(\min_{i=1,2,...,N} |x_i \theta + b| = 1\) which is the nearest neighbour, sign-agnostic for labels here, hence absolute.</li>
<li>Hard to optimize this due to the "min" in the constraint (non-convex form)</li>
<li>To get rid of the absolute value in the constraint, (and to get the correct prediction, predicted value must have same sign as actual)
\[
  \left|x_i \theta + b\right| = y_i(x_i \theta + b) \rightarrow \text{for correct classification} \\
  \text{ if} \min |x_i \theta + b | = 1 \rightarrow \text{ it can be at least 1}
  \]</li>
<li>Hence,
\[
  \max \frac{2}{\parallel \theta \parallel}
  \\
  \text{subject to } y_i (x_i \theta + b) \ge 1 \text{ for } i=1,2,...,N
  \]</li>
</ul>
</div>
</div>
<div id="outline-container-org7ebe2d9" class="outline-4">
<h4 id="org7ebe2d9"><span class="section-number-4">4.2.5.</span> Geometric representation</h4>
<div class="outline-text-4" id="text-4-2-5">

<div id="org05c03dd" class="figure">
<p><img src="./img/geom-rep.png" alt="geom-rep.png" />
</p>
</div>
<dl class="org-dl">
<dt>Decision line</dt><dd>\(x\theta + b = 0\)</dd>
<dt>Margin line</dt><dd>\(x \theta + b = 1\)</dd>
<dt>Blue colors</dt><dd>constraint (data points beyond margin line); beyond margin line the margin &ge; 1, correctly classified</dd>
</dl>
</div>
<ol class="org-ol">
<li><a id="orge6f4f94"></a>Converting problem<br />
<div class="outline-text-5" id="text-4-2-5-1">
<ul class="org-ul">
<li>Many ML libraries can solve minimization problems instead of maximization</li>
<li>Hence, convert from:
\[
  \max(\frac{2}{\parallel \theta \parallel}) \\
  \text{subject to } y_i (x_i \theta + b) \ge 1 \text{ for }i=1,2,...,N
  \]</li>
<li>to:
\[
  \min(\frac{1}{2} \theta\theta^T) \\
  \text{subject to } y_i (x_i \theta + b) \ge 1 \text{ for }i=1,2,...,N
  \]</li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-org5844b4f" class="outline-4">
<h4 id="org5844b4f"><span class="section-number-4">4.2.6.</span> Lagrange formulation (not in detail)</h4>
<div class="outline-text-4" id="text-4-2-6">
<p>
\[
\min(\frac{1}{2} \theta\theta^T) \\
\text{subject to } y_i (x_i \theta + b) -1 \ge 0  \\
\textit{L}(\theta, b, \alpha) = \frac{1}{2}\theta\theta^T - \sum^N_{i=1} \alpha_i (y_i(x_i \theta + b)-1)
\]
becomes:
\[
\min \text{w.r.t. } \theta, b \text{ and } \max \text{w.r.t. each } \alpha_i \ge 0 \\
\nabla_\theta L(\theta, b, \alpha) = \theta - \sum^N_{i=1} \alpha_i y_i x_i = 0 \\
\nabla_b L(\theta, b, \alpha) = -sum^N{i=1} \alpha_i y_i = 0
\]
under KKT conditions,
where:
</p>
<dl class="org-dl">
<dt>\(\theta\)</dt><dd>model parameter</dd>
<dt>\(b\)</dt><dd>bias term</dd>
<dt>\(\alpha\)</dt><dd>Lagrange multiplier</dd>
</dl>
<p>
Need to convert primal form to dual form.
Take gradient w.r.t. &theta;, b, set to 0.
Calculate parametric value of &theta; and new constraints.
Convert objective function to dual form.
\[
\theta = \sum^N_{i=1} \alpha_i y_i x_i \text{ and } \sum^N_{i=1} \alpha_i y_i = 0 \\
L(\theta, b, \alpha) = \sum^N{i=1} \alpha_i - \frac{1}{2} \theta \theta^T \\
L(\theta, b, \alpha) = \sum^N_{i=1} \alpha_i - \frac{1}{2} \sum^N_{i=1} \sum^N_{j=1} y_i y_j \alpha_i \alpha_j x_i x_j^T
\\
\max \text{ w.r.t. each } \alpha_i \ge 0 \text{ for }i=1,...,N \text{ and }
\sum^N_{i=1} \alpha_i y_i = 0
\]
</p>
</div>
</div>
<div id="outline-container-org797ecc2" class="outline-4">
<h4 id="org797ecc2"><span class="section-number-4">4.2.7.</span> Usage</h4>
<div class="outline-text-4" id="text-4-2-7">
<ul class="org-ul">
<li>Dual form good for binary classification, e.g. spam or not spam.</li>
<li>Training
\[
  \theta = \sum^N_{i=1} \alpha_i y_i x_i
  \]
<ul class="org-ul">
<li>No need to go over all data points</li>
<li>\[
    \rightarrow \theta = \sum_{x \in \text{ SV}} \alpha_i y_i x_i
    \]</li>
<li>and for \(b\) pick any support vector, and calculate \(y_i (x_i \theta + b) = 1\)</li>
</ul></li>
<li>Testing
<ul class="org-ul">
<li>For new point \(s\), compute:
\[
    s \theta + b = \sum_{x_i \in \text{ SV}} \alpha_i y_i x_i s^T + b
    \]</li>
<li>Classify \(s\) as class 1 if positive, else classify as class 2.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7ba2ef4" class="outline-4">
<h4 id="org7ba2ef4"><span class="section-number-4">4.2.8.</span> From \(x\) to \(z\) space</h4>
<div class="outline-text-4" id="text-4-2-8">
<ul class="org-ul">
<li>SVM can only be used when a linear decision line can be used</li>
<li>Sometimes it may be possible to work around by moving from Cartesian to Polar space</li>
<li>Not necessarily applicable to NLP since there are many many dimensions.</li>
<li>Instead, kernel trick can be utilised in the dual form model, do feature engineering and handle millions of features.</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="orgbf712f1"></a>Kernel trick<br />
<div class="outline-text-5" id="text-4-2-8-1">
<p>
Main premise is to take data from original space to newer space with higher dimensions, which make it more likely to have linear separation in the newer space.
</p>

<p>
In \(x\) space, they are called pre-images of support vectors.
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-org0bd0b3c" class="outline-4">
<h4 id="org0bd0b3c"><span class="section-number-4">4.2.9.</span> Support vector machine</h4>
<div class="outline-text-4" id="text-4-2-9">
<ul class="org-ul">
<li>Can do <span style='background-color: #FFFF00;'>either</span>
<ul class="org-ul">
<li>Hard classification</li>
<li>Soft classification</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb061d46" class="outline-3">
<h3 id="orgb061d46"><span class="section-number-3">4.3.</span> Perceptron</h3>
<div class="outline-text-3" id="text-4-3">

<div id="org1f43906" class="figure">
<p><img src="./img/spam.png" alt="spam.png" />
</p>
</div>
<ul class="org-ul">
<li>Needs to be linearly separable to work</li>
<li>Can be used for text classification, sentiment analysis</li>
<li><p>
Given training data \((x_i, y_i)\) for \(i = 1,...,N, x_i \in \mathbb{R}^d \text{ and }y_i \in {-1,1}\) learn a classifier \(f(x)\) such that
</p>
\begin{equation}
f(x_i)
\begin{cases}
\ge 0 & +1 & \text{Non-spam document} \\
\lt 0 & -1 & \text{Spam document}
\end{cases}
\end{equation}</li>
<li>i.e. \(y_i f(x_i) \gt 0\) for a correct classification</li>
</ul>
</div>
<div id="outline-container-org0e574b9" class="outline-4">
<h4 id="org0e574b9"><span class="section-number-4">4.3.1.</span> Linearly separable</h4>
<div class="outline-text-4" id="text-4-3-1">

<div id="org9da7cf2" class="figure">
<p><img src="./img/linear-sep.png" alt="linear-sep.png" />
</p>
</div>
<ul class="org-ul">
<li>The two labels must be separable by a <b><b>straight</b></b> line</li>
<li>Perceptron uses linear classifier, as it uses linear combination of features</li>
</ul>
</div>
</div>
<div id="outline-container-orgd2cab88" class="outline-4">
<h4 id="orgd2cab88"><span class="section-number-4">4.3.2.</span> Linear classifier</h4>
<div class="outline-text-4" id="text-4-3-2">
<p>
<img src="./img/lin-class.png" alt="lin-class.png" />
Linear classifier has the form
\[
f(x) = x\theta + \theta_0
\]
</p>
<ul class="org-ul">
<li>In 2D, the discriminant is a line</li>
<li>\(\theta\) is the <b><b>normal</b></b> to the decision line</li>
<li>\(\theta_0\), is the bias term</li>
<li>\(\theta\) is known as the model <span style='background-color: #FFFF00;'>parameter</span> or the <span style='background-color: #FFFF00;'>weight vector</span></li>
<li>Decision boundary has \(d-1\) dimensions where \(d\) is the number of features</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="orgf8e87a2"></a>Linear classifier for higher dimensions<br />
<div class="outline-text-5" id="text-4-3-2-1">
<ul class="org-ul">
<li>In 3D, the discriminant is a plane</li>
<li>in nD, the discriminant is a hyperplane</li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-org30f33a8" class="outline-4">
<h4 id="org30f33a8"><span class="section-number-4">4.3.3.</span> The Perceptron Classifier</h4>
<div class="outline-text-4" id="text-4-3-3">
<ul class="org-ul">
<li><span style='background-color: #FFFF00;'>hard classifier</span></li>
<li>Considering \(x\) is linearly separable</li>
<li>\(y\) has 2 labels \(\{-1,1 \}\)</li>
<li>\(f(x_i) = x_i \theta\), where bias is inside \(\theta\)</li>
<li>How to separate data points with label 1 from those with -1 using a <b><b>line</b></b>?</li>
<li>Perceptron classifier is a simple for-loop
<ul class="org-ul">
<li>Goes inside every single data point to check whether it's classified correctly</li>
</ul></li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org2b7d997"></a>Algorithm<br />
<div class="outline-text-5" id="text-4-3-3-1">

<div id="orgcb7066a" class="figure">
<p><img src="./img/perceptron.png" alt="perceptron.png" />
</p>
</div>
<ol class="org-ol">
<li>Initialise \(\theta = 0\)</li>
<li>Go through each data point \(\{x_i, y_i \}\)
<ol class="org-ol">
<li>If \(x_i\) is misclassified, then \(\theta^{t+1} \leftarrow \theta^t + \alpha y_i x_i\) (i.e. moving the decision line towards the correct label)</li>
</ol></li>
<li>Until all data points are correctly classified</li>
</ol>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgaa845de" class="outline-4">
<h4 id="orgaa845de"><span class="section-number-4">4.3.4.</span> Perceptron activation</h4>
<div class="outline-text-4" id="text-4-3-4">

<div id="org5df763f" class="figure">
<p><img src="./img/perceptron-activation.png" alt="perceptron-activation.png" />
</p>
</div>
<ul class="org-ul">
<li>LHS = number of lines = number of features</li>
<li>output of linear combination of features, \(f(x)\) is real number,</li>
<li>fed into activation function in red, which is +1 or -1</li>
</ul>
</div>
</div>
<div id="outline-container-orgcf3bd3a" class="outline-4">
<h4 id="orgcf3bd3a"><span class="section-number-4">4.3.5.</span> Advantages and disadvantages of Perceptron</h4>
<div class="outline-text-4" id="text-4-3-5">
<ul class="org-ul">
<li>Advantages
<ul class="org-ul">
<li>Very simple</li>
<li>Fast, does not require any parameters</li>
<li>Quick training to optimize parameters</li>
</ul></li>
<li>Disadvantages
<ul class="org-ul">
<li>Works only for linearly separable data</li>
<li>Does not provide unique decision boundary</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org5998cb0" class="outline-2">
<h2 id="org5998cb0"><span class="section-number-2">5.</span> Week 6: Embeddings/Dimensionality reduction</h2>
<div class="outline-text-2" id="text-5">
<p>
Singular Value Decomposition (SVD)
</p>
</div>
<div id="outline-container-org4129b82" class="outline-3">
<h3 id="org4129b82"><span class="section-number-3">5.1.</span> Motivating example</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Dimensionality reduction for text is to understand how they behave in 2D or 3D space.
</p>
<ul class="org-ul">
<li>This helps to get better perspective of the data.</li>
<li>High dimensionality data points happens on text and data problems due to many unique words.</li>
</ul>
</div>
</div>
<div id="outline-container-org3f1f91f" class="outline-3">
<h3 id="org3f1f91f"><span class="section-number-3">5.2.</span> Bag of words representation</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>Has many unique words (dimensions) that leads to:
<ul class="org-ul">
<li><b><b>overfitting</b></b></li>
<li>more resources &amp; time needed</li>
</ul></li>
<li>BoW generates a term-document matrix with many many features that's sparse</li>
<li>Possible solution: <b><b>dimension reduction</b></b></li>
</ul>
</div>
</div>
<div id="outline-container-org89944a2" class="outline-3">
<h3 id="org89944a2"><span class="section-number-3">5.3.</span> What is dimensionality reduction?</h3>
<div class="outline-text-3" id="text-5-3">

<div id="org7601766" class="figure">
<p><img src="./img/dim-reduct.png" alt="dim-reduct.png" />
</p>
</div>
<ul class="org-ul">
<li>Dimensionality reduction is the process of reducing <b><b>random variables</b></b> under consideration</li>
<li>Possible approaches:
<ul class="org-ul">
<li>Combine, transform or select variables</li>
<li>With linear or non-linear operations</li>
</ul></li>
<li>New space has lower dimensions than previous space</li>
</ul>
</div>
</div>
<div id="outline-container-org956d61a" class="outline-3">
<h3 id="org956d61a"><span class="section-number-3">5.4.</span> Intuition (of PCA)</h3>
<div class="outline-text-3" id="text-5-4">
<ul class="org-ul">
<li>Approximate a \(D\) -dimensional dataset using fewer dimensions</li>
<li>By rotating the axes into a new space</li>
<li>Highest order dimension captures the most variance in the original dataset</li>
<li>Next dimension captures the next most variance, etc.</li>
<li>PCA uses eigendecomposition of covariance of dataset to maximize variance
<ul class="org-ul">
<li>Eigenvector corresponding to the highest eigenvalue is the new dimension that maximises the variance the most</li>
<li>Hope of PCA is that a dimension that explains variance the most would explain data better and it's easier to separate and distinguish labels when data points are spread out because of high variance</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org83b0e62" class="outline-3">
<h3 id="org83b0e62"><span class="section-number-3">5.5.</span> Singular value decomposition</h3>
<div class="outline-text-3" id="text-5-5">
<p>
For a matrix \(X_{n \times d}\) where:
</p>
<dl class="org-dl">
<dt>n</dt><dd>number of instances</dd>
<dt>d</dt><dd>dimension</dd>
</dl>

<p>
\[
X = U \Sigma V^T
\]
</p>

<dl class="org-dl">
<dt>U, &Sigma;, V</dt><dd>all unitary matrices</dd>
<dt>m columns</dt><dd>represent a dimension in a new latent space s.t. \(m\) column vectors are orthogonal to each other, and ordered by the amount of variance in the dataset in each dimension. \(m\) has <b><b>maximum</b></b> of \(d\) dimensions</dd>
<dt>\(U_{n \times m}\)</dt><dd>unitary matrix &rarr; \(UU^T = I\)</dd>
<dt>\(\Sigma_{m \times m}\)</dt><dd>diagonal matrix of singular values of \(X\)</dd>
<dt>\(V_{m \times d}\)</dt><dd>unitary matrix \(\rightarrow VV^T = I\)</dd>
</dl>
</div>
</div>
<div id="outline-container-org95fd720" class="outline-3">
<h3 id="org95fd720"><span class="section-number-3">5.6.</span> Co-occurrence matrices</h3>
<div class="outline-text-3" id="text-5-6">
<div class="BLOCKQUOTE" id="org750e4b8">
<p>
Instead of matrix.
</p>

</div>
<p>
Each matrix for one value of context length.
</p>

<ul class="org-ul">
<li>Meaning of a word is defined by the words in its surroundings</li>
<li>Define a context window as the number of words appearing around a centre word</li>
<li>Create a co-occurrence matrix:
<ol class="org-ol">
<li>Go through each central word-context pair in corpus (context window length is commonly in \([1,5]\))</li>
<li>In each iteration, update the row of the count matrix (of central word) by adding +1 in the columns for the context words</li>
<li>Repeat last step many times</li>
</ol></li>
</ul>

<div id="org5858cdf" class="figure">
<p><img src="./img/co-matrix.png " alt="co-matrix.png " />
</p>
</div>
</div>
</div>
<div id="outline-container-orged691ef" class="outline-3">
<h3 id="orged691ef"><span class="section-number-3">5.7.</span> SVD on co-occurrence matrices</h3>
<div class="outline-text-3" id="text-5-7">
<ul class="org-ul">
<li>For corpus with vocabulary \(V\) of size \(d\), co-occurrence matrix has size \(d \times d\)</li>
<li>Size of co-occurrence matrix increases with vocabulary</li>
<li>Instead of keeping all dimensions, can instead use truncated SVD to keep only to \(k\) singular values
<ul class="org-ul">
<li>e.g. \(k=300\)</li>
</ul></li>
<li>Result is a least-square approximation to the original co-occurrence matrix \(X\)
<img src="./img/svd-co-occur.png" alt="svd-co-occur.png" /></li>
<li>Single value is directly related to the new dimension that maximizes co-variance</li>
</ul>
</div>
</div>
<div id="outline-container-org0a9926b" class="outline-3">
<h3 id="org0a9926b"><span class="section-number-3">5.8.</span> Dense word embeddings</h3>
<div class="outline-text-3" id="text-5-8">

<div id="orgc5aabda" class="figure">
<p><img src="./img/dense.png" alt="dense.png" />
</p>
</div>
<ul class="org-ul">
<li>Each row of \(U\) is a \(k\) -dimensional representation of each word \(w\) in the corpus that best preserves variance</li>
<li>Generally, keep top \(k \in [50, 500]\) dimensions.</li>
<li>Produces dense vectors for word representations, while also considering the word contexts that carry meaning</li>
</ul>
</div>
</div>
<div id="outline-container-org0f569f8" class="outline-3">
<h3 id="org0f569f8"><span class="section-number-3">5.9.</span> Advantages of dense word embeddings</h3>
<div class="outline-text-3" id="text-5-9">
<ul class="org-ul">
<li>Denoising: low-order dimensions may represent unimportant information; higher-order dimensions keep only important information</li>
<li>Truncation may help models generalize better to unseen data</li>
<li>Having smaller number of dimensions may make it easier for classifiers to properly weigh the dimensions</li>
<li>Dense models may do better at capturing higher-order co-occurrence</li>
<li>Dense vectors work better in word similarity</li>
<li>Example of word-similarity method is cosine similarity between two word-embeddings \(w, v\):
\[
  \text{cosine} (\vec{v}, \vec{w}) =
  \frac{\vec{v}\cdot \vec{w}}{|\vec{v}| |\vec{w}|}
  = \frac{\sum^N_{i=1}v_i w_i}{\sqrt{\sum^N_{i=1} v_i^2} \sqrt{\sum^N_{i=1} w_i^2}}
  \]</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: W</p>
<p class="date">Created: 2024-02-25 Sun 21:57</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
